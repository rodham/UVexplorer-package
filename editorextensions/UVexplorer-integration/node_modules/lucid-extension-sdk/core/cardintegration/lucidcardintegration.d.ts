import { CollectionDefinition } from '../../data/collectiondefinition';
import { CollectionProxy } from '../../data/collectionproxy';
import { DataSourceProxy } from '../../data/datasourceproxy';
import { TextStyle } from '../../document/text/textstyle';
import { EditorClient } from '../../editorclient';
import { SerializedFieldType } from '../data/serializedfield/serializedfields';
import { JsonSerializable } from '../jsonserializable';
import { CardIntegrationConfig } from './cardintegrationconfig';
import { ExtensionCardFieldDefinition } from './cardintegrationdefinitions';
/**
 * Result of searching for data in the import modal
 */
export interface SearchResult {
    partialImportMetadata?: {
        collectionId: string;
        syncDataSourceId?: string;
    };
    data: CollectionDefinition;
    fields: ExtensionCardFieldDefinition[];
}
/**
 * Result of importing data from  the import modal
 */
export interface ImportResult {
    collection: CollectionProxy;
    primaryKeys: string[];
}
export declare abstract class LucidCardIntegration {
    protected readonly client: EditorClient;
    constructor(client: EditorClient);
    /**
     * Label used to identify the integration, e.g. "Jira", which will be used in menu items, etc.
     * Should be unique within any given extension.
     */
    abstract label: string;
    /**
     * Label used to identify one card worth of data, e.g. "Jira task"
     */
    abstract itemLabel: string;
    /**
     * Label used to identify multiple cards worth of data, e.g. "Jira tasks"
     */
    abstract itemsLabel: string;
    /**
     * URL for an icon to display in toolbars, etc. Should be at least 24x24.
     */
    abstract iconUrl: string;
    /**
     * The name of the data connector associated with the card integration.
     */
    abstract dataConnectorName: string;
    /**
     * The default text style to use on cards created as part of this integration.
     * These can be overridden by values in getDefaultConfig().fieldStyles for
     * individual fields that should have different styles.
     */
    textStyle?: Partial<TextStyle>;
    abstract fieldConfiguration: {
        /**
         * Callback to provide a list of all supported field names for the card integration.
         */
        getAllFields: (dataSource: DataSourceProxy) => Promise<string[]>;
        /**
         * Callback that handled changes in the fields the user wants to be displayed in the card integration.
         * If this callback is not provided then the user will not be shown the modal to configure fields.
         */
        onSelectedFieldsChange?: (dataSource: DataSourceProxy, selectedFields: string[]) => Promise<void>;
        /**
         * Specify callbacks for searching for legal values for the given fields.
         *
         * For example, a Task collection may have an Assignee field that references a User collection,
         * but you don't import all the users in the entire source data set. Here, you can provide a way
         * to search for legal values for the Assignee field, similar to the `ExtensionCardFieldDefinition.search`
         * functionality.
         *
         * Register a search callback using LucidCardIntegrationRegistry.registerFieldSearchCallback, then set
         * the returned string as a value in this Map. The `inputSoFar` parameter passed to the callback will
         * be all the current field values on the item being edited.
         */
        fieldValueSearchCallbacks?: Map<string, string>;
    };
    /**
     * If specified, and the user hasn't yet authorized the data connector for this extension,
     * this should show the user an intro dialog or take some other action.
     */
    showIntro?: () => void;
    /**
     * Provide the default configuration for a new import
     */
    abstract getDefaultConfig: (dataSource: DataSourceProxy) => Promise<CardIntegrationConfig>;
    /**
     * If specified, allow the user to import cards using the standard card-import modal.
     *
     * getSearchFields:
     * Given the values entered by the user so far into search fields, return the list of all search fields
     * to display in the search form.
     *
     * search:
     * Given values entered by the user into the search fields so far, return a collection of data to
     * display in the results table. If partialImportMetadata is also returned, it will be used to create the tasks cards before
     * the import is completedâ€”which allows users to interact with the cards while the
     * data is fetched asynchronously. The collectionId needs to match the id that will be
     * returned from the completed import. The syncDataSourceId needs to match the
     * syncDataSourceId that is passed into performDataAction.
     * The last requirement for the partial import to work is that the primary keys in the data also
     * returned in this search need to match the primary keys that will be returned
     * on import.
     *
     * import:
     * The user checked the boxes beside the given list of items in the collection returned from search().
     * Import them, and return the collection and primary keys in that final collection that were imported.
     *
     * onSetup:
     * If specified, it's going to be called everytime the modal is setting up, right after the modal is displayed
     * and before the initial form fields are shown to the user.
     *
     * The config provided here is only used on the first import from a given source; on subsequent imports,
     * the existing config will remain unchanged to preserve any customizations by the user.
     */
    importModal?: {
        getSearchFields: (searchSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        search: (fields: Map<string, SerializedFieldType>) => Promise<SearchResult>;
        import: (primaryKeys: string[], searchFields: Map<string, SerializedFieldType>) => Promise<ImportResult>;
        onSetup?: () => Promise<void>;
    };
    /**
     * If specified, allow the user to import cards using a custom card-import modal.
     *
     * srcUrl:
     * The url to be displayed in an iframe. This can either be a public url, or a local
     * file located in the public folder of your packages root directory.
     *
     * width:
     * The width of the iframe. The maximum width is 1344px.
     *
     * height:
     * The height of the iframe. The maximum height is 1000px.
     *
     * import:
     * Imports the items selected from you custom iframe. You can pass in whatever data is needed to import the items
     * through you data-connector. The data must be of type JsonSerializable. Return the collection created and the
     * primary keys of the items that were imported.
     *
     */
    customImportModal?: {
        srcUrl: string;
        width: number;
        height: number;
        import: (data: JsonSerializable) => Promise<ImportResult>;
    };
    /**
     * If specified, allow the user to create new cards and convert other shapes to cards
     */
    addCard?: {
        /**
         * Given the values entered by the user so far into input fields, return the list of all input fields
         * to display in the create-card form.
         */
        getInputFields: (inputSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        /**
         * Given the values entered by the user into input fields, create a new data record to represent the
         * created card, and return information about that record.
         */
        createCardData: (input: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKey: string;
        }>;
    };
    showCardImport(name: string): import("../../commandtypes").ImportCardsResult;
}
