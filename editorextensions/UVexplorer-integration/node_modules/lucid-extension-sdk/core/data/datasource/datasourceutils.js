"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSerializedImportedDataSource = exports.makeSerializedImportedCollection = exports.MetadataPK = exports.makeNameReadablyUnique = exports.normalizeName = exports.alphabetize = void 0;
const dataupdatefiltertype_1 = require("../../../data/dataupdatefiltertype");
const checks_1 = require("../../checks");
const scalarfieldtype_1 = require("../fieldtypedefinition/scalarfieldtype");
const alphabet_1 = require("./alphabet");
const datasourcetype_1 = require("./datasourcetype");
const spreadsheetpossibledatatypes_1 = require("./spreadsheetpossibledatatypes");
const upstreamupdatetype_1 = require("./upstreamupdatetype");
/** @ignore */
function _alphabetize(n) {
    if (n == undefined || n < 0) {
        return '';
    }
    else if (n < alphabet_1.alphabet.length) {
        return alphabet_1.alphabet[n];
    }
    else {
        return alphabetize(Math.floor(n / alphabet_1.alphabet.length) - 1) + alphabetize(n % alphabet_1.alphabet.length);
    }
}
/** @ignore */
const memoize = new Map();
/** @ignore */
function alphabetize(n) {
    const stored = memoize.get(n);
    if (stored != null) {
        return stored;
    }
    const value = _alphabetize(n);
    memoize.set(n, value);
    return value;
}
exports.alphabetize = alphabetize;
/** @ignore */
function normalizeName(name) {
    return name.trim().toLowerCase();
}
exports.normalizeName = normalizeName;
const appendedNumberRegex = /(.*) \(([0-9]+)\)$/;
/** @ignore */
function makeNameReadablyUnique(originalName, usedNamesNormalized, transform = normalizeName) {
    if (!usedNamesNormalized.has(transform(originalName))) {
        return originalName;
    }
    const match = appendedNumberRegex.exec(originalName);
    let count = 1;
    if (match && (0, checks_1.isString)(match[1]) && (0, checks_1.isString)(match[2])) {
        originalName = match[1];
        count = Number(match[2]) + 1;
    }
    let newName = originalName;
    do {
        newName = originalName + ` (${count})`;
        count++;
    } while (usedNamesNormalized.has(transform(newName)));
    return newName;
}
exports.makeNameReadablyUnique = makeNameReadablyUnique;
/** @ignore */
exports.MetadataPK = '__PK__';
/** @ignore */
function makePrimaryCollectionSchema(rawSchemaFields, data, schemaFromData) {
    var _a, _b;
    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;
    const headerRowData = headerRow >= 0 ? data[headerRow] : undefined;
    const headerRowAsStringArray = headerRowData &&
        rawSchemaFields.map((rawSchemaField, index) => {
            var _a;
            const headerRowDataAsString = `${(_a = headerRowData[rawSchemaField]) !== null && _a !== void 0 ? _a : ''}`;
            return headerRowDataAsString.trim() === '' ? alphabetize(index) : headerRowDataAsString;
        });
    const schemaFields = headerRowAsStringArray !== null && headerRowAsStringArray !== void 0 ? headerRowAsStringArray : rawSchemaFields;
    const fields = [];
    const oldToNewFields = new Map();
    const usedFieldsNormalized = new Set([normalizeName(exports.MetadataPK)]);
    schemaFields.forEach((field, index) => {
        const finalFieldName = makeNameReadablyUnique(field, usedFieldsNormalized);
        usedFieldsNormalized.add(normalizeName(finalFieldName));
        fields.push({ 'Name': finalFieldName, 'Type': spreadsheetpossibledatatypes_1.SpreadSheetPossibleDataTypes });
        oldToNewFields.set(rawSchemaFields[index], finalFieldName);
    });
    const oldPrimaryKeys = (_b = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.primaryKey) !== null && _b !== void 0 ? _b : [];
    const translatedPrimaryKeys = oldPrimaryKeys
        .map((oldPrimaryKey) => oldToNewFields.get(oldPrimaryKey))
        .filter(checks_1.isDefAndNotNull); // There should be no untranslatable primary keys, but we need to satisfy the type system
    return {
        sheetSchema: {
            'Fields': fields,
            'PrimaryKey': translatedPrimaryKeys,
        },
        oldToNewFields,
    };
}
function getPrimaryKeysForData(oldToNewFields, data, schemaFromData) {
    if (!schemaFromData || schemaFromData.primaryKey.length === 0) {
        return data.map((row, index) => `${index + 1}`);
    }
    const primaryKey = schemaFromData.primaryKey;
    const primaryKeyInNewFields = primaryKey.map((oldField) => { var _a; return (_a = oldToNewFields.get(oldField)) !== null && _a !== void 0 ? _a : oldField; });
    // For reasons I have forgotten, the actual primary key order is determined by the alphabetized name order.
    const sortedPrimaryKeyInNewFields = primaryKeyInNewFields.slice().sort();
    const sortedPrimaryKey = sortedPrimaryKeyInNewFields.map((newField) => primaryKey[primaryKeyInNewFields.indexOf(newField)]);
    const usedNames = new Set();
    return data.map((serializedField) => {
        const primaryKeyValues = sortedPrimaryKey.map((key) => serializedField[key]);
        const compositeValue = JSON.stringify(primaryKeyValues);
        const nameWithoutContext = compositeValue.slice(1, compositeValue.length - 1);
        let name = nameWithoutContext;
        let dupCount = -1;
        while (usedNames.has(name)) {
            name = `${nameWithoutContext},${++dupCount}`;
        }
        usedNames.add(name);
        return name;
    });
}
/** @ignore */
function makeMetadataCollection(metadataType, sheetName, dataItems, sheetSchema) {
    return {
        'Name': sheetName + '|' + metadataType,
        'Schema': sheetSchema,
        'Items': dataItems,
    };
}
/** @ignore */
function makeItemOrderCollection(primaryKeys, sheetName, headerRow) {
    const itemOrderItems = {};
    let rowIndex = 0;
    for (let i = 0; i < primaryKeys.length; i++) {
        const primaryKey = primaryKeys[i];
        if (i !== headerRow) {
            rowIndex++;
            itemOrderItems[`${rowIndex}`] = { 'Key': `${primaryKey}`, 'Order': rowIndex };
        }
    }
    const itemOrderSchema = {
        'Fields': [
            { 'Name': 'Key', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING },
            { 'Name': 'Order', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER },
        ],
        'PrimaryKey': ['Order'],
    };
    return makeMetadataCollection('ItemOrder', sheetName, itemOrderItems, itemOrderSchema);
}
/** @ignore */
function makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, sheetName, schema) {
    const dataItem = {};
    for (const [key, field] of Object.entries(headerRowData)) {
        const newKey = oldToNewFields.get(key);
        if (newKey) {
            dataItem[newKey] = field;
        }
    }
    const itemOrderItems = {
        [headerRowPrimaryKey]: dataItem,
    };
    return makeMetadataCollection('HeaderRowMetadata', sheetName, itemOrderItems, schema);
}
/** @ignore */
function makeSerializedItems(primaryKeys, rawItems, oldToNewFields, headerRow, isMetadata = false) {
    const serializedItems = {};
    rawItems.forEach((rawItem, rowIndex) => {
        if (isMetadata || rowIndex !== headerRow) {
            const dataItem = {};
            for (const [key, field] of Object.entries(rawItem)) {
                const newKey = oldToNewFields.get(key);
                if (newKey) {
                    dataItem[newKey] = field;
                }
            }
            const primaryKey = primaryKeys[rowIndex];
            if (isMetadata && Object.keys(dataItem).length > 0) {
                const metadataPrimaryKey = `${primaryKey}`;
                dataItem[exports.MetadataPK] = metadataPrimaryKey;
                serializedItems[`${JSON.stringify(metadataPrimaryKey)}`] = dataItem;
            }
            else if (!isMetadata) {
                serializedItems[primaryKey] = dataItem;
            }
        }
    });
    return serializedItems;
}
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
function makeSerializedImportedCollection(name, rawFieldNames, data, upstreamConfig, dataIsPartial, metadata, schemaFromData) {
    var _a;
    const { sheetSchema, oldToNewFields } = makePrimaryCollectionSchema(rawFieldNames, data, schemaFromData);
    const primaryKeys = getPrimaryKeysForData(oldToNewFields, data, schemaFromData);
    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;
    const metadataCollections = {};
    metadataCollections['ItemOrder'] = makeItemOrderCollection(primaryKeys, name, headerRow);
    if (headerRow > -1 && headerRow < data.length) {
        const headerRowData = data[headerRow];
        const headerRowPrimaryKey = primaryKeys[headerRow];
        metadataCollections['HeaderRowMetadata'] = makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, name, sheetSchema);
    }
    if (metadata) {
        const metadataFields = [{ 'Name': exports.MetadataPK, 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING }];
        sheetSchema['Fields'].forEach((field) => metadataFields.push({
            'Name': field['Name'],
            'Type': [scalarfieldtype_1.ScalarFieldTypeEnum.STRING, scalarfieldtype_1.ScalarFieldTypeEnum.NULL],
        }));
        const metadataSchema = { 'Fields': metadataFields, 'PrimaryKey': [exports.MetadataPK] };
        for (const [type, data] of Object.entries(metadata)) {
            metadataCollections[type] = makeMetadataCollection(type, name, makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow, true), metadataSchema);
        }
    }
    return {
        'Name': name,
        'Schema': sheetSchema,
        'Items': makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow),
        'UpstreamConfig': upstreamConfig,
        'Metadata': metadataCollections,
        'DataIsPartial': dataIsPartial,
    };
}
exports.makeSerializedImportedCollection = makeSerializedImportedCollection;
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
function makeSerializedImportedDataSource(id, name, collections) {
    return {
        'Properties': {
            'Name': name,
            'UpstreamConfig': {
                'SourceType': datasourcetype_1.DataSourceType.DataService,
                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,
                'SourceConfig': {
                    'spreadsheetId': id,
                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,
                },
            },
        },
        'Collections': collections,
    };
}
exports.makeSerializedImportedDataSource = makeSerializedImportedDataSource;
