"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInstanceOf = exports.isLiteral = exports.isPromise = exports.isUnknown = exports.isAny = exports.isEmptyOrNullishObject = exports.isAtLeastLength = exports.isExactLength = exports.isTypedArray = exports.isArray = exports.isRecord = exports.isObjectUnsafer = exports.isObjectUnsafe = exports.isObject = exports.isFunction = exports.isInfinite = exports.isInt = exports.isNumber = exports.isBoolean = exports.isString = exports.isNullish = exports.isDefAndNotNull = exports.isVoid = exports.isUndefined = exports.isNull = exports.isDef = void 0;
/**
 * Returns true if the specified value is not undefined.
 *
 * @param val Variable to test.
 * @return Whether variable is defined.
 */
function isDef(val) {
    return val !== undefined;
}
exports.isDef = isDef;
/**
 * Returns true if the specified value is null.
 * @param val Variable to test.
 * @return Whether variable is null.
 */
function isNull(val) {
    return val === null;
}
exports.isNull = isNull;
/**
 * Returns true if the specified value is undefined.
 * @param val Variable to test.
 * @return Whether variable is undefined.
 */
function isUndefined(val) {
    return val === undefined;
}
exports.isUndefined = isUndefined;
/**
 * Returns true if the specified value is undefined.
 * @param val Variable to test.
 * @return Whether variable is undefined.
 */
function isVoid(x) {
    return x === undefined;
}
exports.isVoid = isVoid;
/**
 * Returns true if the specified value is defined and not null.
 * @param val Variable to test.
 * @return Whether variable is defined and not null.
 */
function isDefAndNotNull(val) {
    return val != null;
}
exports.isDefAndNotNull = isDefAndNotNull;
/**
 * Returns true if the specified value is null or undefined.
 * @param val Variable to test
 * @return Whether the variable is null or undefined.
 */
function isNullish(val) {
    return val == null;
}
exports.isNullish = isNullish;
/**
 * Returns true if the specified value is a string.
 * @param val Variable to test.
 * @return Whether variable is a string.
 */
function isString(val) {
    return typeof val == 'string';
}
exports.isString = isString;
/**
 * Returns true if the specified value is a boolean.
 * @param val Variable to test.
 * @return Whether variable is boolean.
 */
function isBoolean(val) {
    return typeof val == 'boolean';
}
exports.isBoolean = isBoolean;
/**
 * Returns true if the specified value is a number.
 * @param val Variable to test.
 * @return Whether variable is a number.
 */
function isNumber(val) {
    return typeof val == 'number';
}
exports.isNumber = isNumber;
/**
 * Returns true if the specified value is an integer.
 * @param val Variable to test.
 * @return Whether variable is an integer.
 */
function isInt(val) {
    return isNumber(val) && isFinite(val) && val % 1 == 0;
}
exports.isInt = isInt;
/**
 * Returns true if the specified value is either positive or negative infinity.
 * @param val Variable to test.
 * @returns Whether variable is positive or negative infinity.
 */
function isInfinite(val) {
    return isNumber(val) && !isNaN(val) && !isFinite(val);
}
exports.isInfinite = isInfinite;
function isFunction(val) {
    return typeof val === 'function';
}
exports.isFunction = isFunction;
/**
 * Returns true if the specified value is an object (including arrays and functions) (i.e. it's safe to do property accesses on it).
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
function isObject(val) {
    const type = typeof val;
    return (type == 'object' && val != null) || type == 'function';
}
exports.isObject = isObject;
/**
 * Returns true for objects, includings arrays and functions.
 * Matches the behavior of goog.isObject, with a more permissive type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
function isObjectUnsafe(val) {
    const type = typeof val;
    return (type == 'object' && val != null) || type == 'function';
}
exports.isObjectUnsafe = isObjectUnsafe;
/**
 * Returns true for objects, includings arrays and functions.
 * Matches the behavior of goog.isObject, with an extremely permissive type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
function isObjectUnsafer(val) {
    const type = typeof val;
    return (type == 'object' && val != null) || type == 'function';
}
exports.isObjectUnsafer = isObjectUnsafer;
/**
 * Returns true if the specified value is an object (i.e. it's safe to do property accesses on it),
 * and every value matches the record type.
 *
 * @param val Variable to test.
 * @return Whether variable is an object.
 */
function isRecord(typeGuard) {
    return function (val) {
        return isObject(val) && Object.values(val).every(typeGuard);
    };
}
exports.isRecord = isRecord;
/**
 * Returns true if the specified value is an array.
 *
 * This is safer than using Array.isArray directly because it doesn't introduce an `any` type.
 * @param val Variable to test.
 * @return Whether variable is an array.
 */
function isArray(val) {
    return Array.isArray(val);
}
exports.isArray = isArray;
/**
 * Returns true if the specified value is an array and every element passes the type guard function.
 *
 * @param val Variable to test.
 * @param typeGuard the type guard function to test every element in the array.
 * @return Whether variable is an array of the given type.
 */
function isTypedArray(typeGuard) {
    return function (val) {
        return isArray(val) && val.every(typeGuard);
    };
}
exports.isTypedArray = isTypedArray;
function isExactLength(arr, exactLength) {
    return arr.length === exactLength;
}
exports.isExactLength = isExactLength;
function isAtLeastLength(arr, minimumLength) {
    return arr.length >= minimumLength;
}
exports.isAtLeastLength = isAtLeastLength;
/**
 * Returns true if the specified object is either empty or all existing keys map to a nullish value
 *
 * @param val Variable to test
 * @return Whether variable is empty or maps exclusively to nullish values
 */
function isEmptyOrNullishObject(val) {
    return !(val &&
        typeof val === 'object' &&
        Object.keys(val).find((key) => isDefAndNotNull(val[key])));
}
exports.isEmptyOrNullishObject = isEmptyOrNullishObject;
/**
 * @deprecated Prefer isUnknown
 */
function isAny(val) {
    return true;
}
exports.isAny = isAny;
function isUnknown(val) {
    return true;
}
exports.isUnknown = isUnknown;
function isPromise(val) {
    return isObjectUnsafe(val) && isFunction(val['then']) && isFunction(val['catch']);
}
exports.isPromise = isPromise;
function isLiteral(t) {
    return (x) => x === t;
}
exports.isLiteral = isLiteral;
/**
 * Since `instanceof` should generally be avoided, this function should generally be avoided as well.
 *
 * A valid use case is for native types, like Uint8Array.
 */
function isInstanceOf(klass) {
    return (x) => x instanceof klass;
}
exports.isInstanceOf = isInstanceOf;
