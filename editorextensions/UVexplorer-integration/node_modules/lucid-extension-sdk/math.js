"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rotateAroundFn = exports.toCornersAsArray = exports.boxFrom4Points = exports.rotateBox = exports.rotatedBoundingBox = exports.boxCenter = exports.clip = exports.percentBoxesOverlap = exports.boxesOverlap = exports.isBoxWithin = exports.padBox = exports.combinedBoundingBox = void 0;
function combinedBoundingBox(boxes) {
    if (boxes.length == 0) {
        return undefined;
    }
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    for (const box of boxes) {
        minX = Math.min(minX, box.x);
        maxX = Math.max(maxX, box.x + box.w);
        minY = Math.min(minY, box.y);
        maxY = Math.max(maxY, box.y + box.h);
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
}
exports.combinedBoundingBox = combinedBoundingBox;
function padBox(box, padding) {
    return { x: box.x - padding, y: box.y - padding, w: box.w + padding * 2, h: box.h + padding * 2 };
}
exports.padBox = padBox;
/**
 * Is box a completely within box b?
 */
function isBoxWithin(a, b) {
    return a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h;
}
exports.isBoxWithin = isBoxWithin;
/**
 * Do two boxes overlap?
 */
function boxesOverlap(a, b) {
    return a.x + a.w >= b.x && a.y + a.h >= b.y && b.x + b.w >= a.x && b.y + b.h >= a.y;
}
exports.boxesOverlap = boxesOverlap;
/**
 * return the percentage of a that overlaps with b.
 * if a is entirely within b, it returns 1 (or a number a little less than 1
 * (e.g., 0.99999999999) due to numerical inaccuracy); if a is entirely
 * outside b, it returns 0.
 */
function percentBoxesOverlap(a, b) {
    const intersection = clip(a, b);
    // if either dimension is negative return zero
    if (intersection.w <= 0 || intersection.h <= 0) {
        return 0;
    }
    const area = intersection.w * intersection.h;
    return area / (a.w * a.h);
}
exports.percentBoxesOverlap = percentBoxesOverlap;
/**
 * Gets the intersection of two boxes
 * @return a clipped to b
 */
function clip(a, b) {
    const x = Math.max(a.x, b.x);
    const y = Math.max(a.y, b.y);
    const w = Math.min(a.x + a.w, b.x + b.w) - x;
    const h = Math.min(a.y + a.h, b.y + b.h) - y;
    return { x, y, w, h };
}
exports.clip = clip;
function boxCenter(b) {
    return { x: b.x + b.w / 2, y: b.y + b.h / 2 };
}
exports.boxCenter = boxCenter;
/**
 * Returns the bounding box that would surround the given
 * box when rotated the given amount.
 */
function rotatedBoundingBox(b, angle, center) {
    if (!angle) {
        return b;
    }
    center = center || boxCenter(b);
    return boxFrom4Points.apply(null, rotateBox(b, angle, center));
}
exports.rotatedBoundingBox = rotatedBoundingBox;
function rotateBox(b, angle, center) {
    const ret = toCornersAsArray(b);
    center = center || boxCenter(b);
    if (angle != 0) {
        return ret.map(rotateAroundFn(center, angle));
    }
    return ret;
}
exports.rotateBox = rotateBox;
function boxFrom4Points(a, b, c, d) {
    const xMin = Math.min(a.x, b.x, c.x, d.x);
    const xMax = Math.max(a.x, b.x, c.x, d.x);
    const yMin = Math.min(a.y, b.y, c.y, d.y);
    const yMax = Math.max(a.y, b.y, c.y, d.y);
    return { x: xMin, y: yMin, w: xMax - xMin, h: yMax - yMin };
}
exports.boxFrom4Points = boxFrom4Points;
function toCornersAsArray(box) {
    return [
        { x: box.x, y: box.y },
        { x: box.x + box.w, y: box.y },
        { x: box.x + box.w, y: box.y + box.h },
        { x: box.x, y: box.y + box.h },
    ];
}
exports.toCornersAsArray = toCornersAsArray;
function rotateAroundFn(anchor, angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    return (p) => {
        const anchorX = anchor.x;
        const anchorY = anchor.y;
        const x = p.x - anchorX;
        const y = p.y - anchorY;
        return { x: x * cos - y * sin + anchorX, y: y * cos + x * sin + anchorY };
    };
}
exports.rotateAroundFn = rotateAroundFn;
