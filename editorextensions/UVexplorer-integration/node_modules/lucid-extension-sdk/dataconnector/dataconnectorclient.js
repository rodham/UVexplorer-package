"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockDataConnectorClient = exports.DataConnectorClient = void 0;
const checks_1 = require("../core/checks");
const serializedactions_1 = require("./actions/serializedactions");
const datasourceclient_1 = require("./datasourceclient");
const defaultfetchfunction_1 = require("./defaultfetchfunction");
const signaturevalidator_1 = require("./signaturevalidator");
const throwunsuccessful_1 = require("./throwunsuccessful");
const LUCID_URLS = { main: 'https://lucid.app/', api: 'https://api.lucid.co/' };
/**
 * Client for requests to and from Lucid
 */
class DataConnectorClient {
    constructor(cryptoDependencies, urls = LUCID_URLS, fetchMethod = defaultfetchfunction_1.globalFetch) {
        this.cryptoDependencies = cryptoDependencies;
        this.urls = urls;
        this.fetchMethod = fetchMethod;
        this.cachedPublicKey = undefined;
    }
    /** Get a client for DataSource related requests to Lucid */
    getDataSourceClient(updateToken) {
        return new datasourceclient_1.DataSourceClient(this.urls, updateToken, this.fetchMethod);
    }
    /** Get a validator to prove a given request came from Lucid */
    async getSignatureValidator() {
        return new signaturevalidator_1.SignatureValidator(this.cryptoDependencies, await this.getPublicKey());
    }
    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe
     * you're not running in a NodeJS environment */
    async getPublicKey() {
        if (!this.cachedPublicKey) {
            const url = `${this.urls.main}.well-known/pem/TPCP`;
            const result = await this.fetchMethod(url);
            await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting public key');
            this.cachedPublicKey = await result.text();
        }
        return this.cachedPublicKey;
    }
    /** Validate and parse an action request from Lucid */
    async parseActions(url, headers, actions) {
        if (!(0, serializedactions_1.actionsHeaderValidator)(headers)) {
            return;
        }
        if (!(await this.getSignatureValidator()).validate(actions, headers, url)) {
            return;
        }
        return (0, serializedactions_1.deserializeActions)(this, actions);
    }
    /** @ignore */
    async getSecretFromWebhook(webhookUpdateToken, WebhookValidationSecret) {
        // todo: this should be using the public API
        const result = await this.fetchMethod(`${this.urls.dataSync}webhookAuthorization`, {
            headers: {
                'data-update-token': webhookUpdateToken,
                'webhook-validation-secret': JSON.stringify(WebhookValidationSecret),
            },
        });
        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting secret from webhook');
        const responseBody = await result.json();
        if ((0, checks_1.isString)(responseBody)) {
            return responseBody;
        }
        else {
            return undefined;
        }
    }
    /** @ignore */
    async getCustomWebhookData(webhookUpdateToken) {
        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {
            headers: { 'data-update-token': webhookUpdateToken },
        });
        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting custom webhook data');
        return (await result.json());
    }
    /** @ignore */
    async patchCustomWebhookData(webhookUpdateToken, patch) {
        // todo: this should be using the public API
        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {
            method: 'PATCH',
            'headers': {
                'Content-Type': 'application/json',
                'data-update-token': webhookUpdateToken,
                'Lucid-Api-Version': '1',
            },
            body: JSON.stringify(patch),
        });
        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'patching custom webhook data');
        return (await result.json());
    }
}
exports.DataConnectorClient = DataConnectorClient;
/** Use this for writing automated tests for your data connector */
class MockDataConnectorClient extends DataConnectorClient {
    constructor() {
        super(undefined);
        /** set properties on this to modify how data source updates are mocked */
        this.dataSourceClient = new datasourceclient_1.MockDataSourceClient();
    }
    /** @ignore */
    getDataSourceClient(updateToken) {
        return this.dataSourceClient;
    }
    /** Mocked version just always returns successful */
    getSignatureValidator() {
        return Promise.resolve(new signaturevalidator_1.MockSignatureValidator());
    }
    /** Mocked version returns an empty string */
    getPublicKey() {
        return Promise.resolve('');
    }
}
exports.MockDataConnectorClient = MockDataConnectorClient;
