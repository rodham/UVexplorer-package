"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataConnectorManageWebhookAction = exports.Webhook = exports.DataConnectorPatchAction = exports.Patch = exports.DataConnectorSynchronousAction = exports.DataConnectorAsynchronousAction = exports.DataConnectorAction = exports.DataConnectorActionContext = void 0;
const dataconnectoractionkeys_1 = require("./dataconnectoractionkeys");
const patchresponsebody_1 = require("./patchresponsebody");
/**
 * This holds all the contextual information about a give data action.
 */
class DataConnectorActionContext {
    constructor(
    /** The package ID of the extension that triggered this action */
    packageId, 
    /** The version of the extension that triggered this action */
    packageVersion, 
    /** The authorized OAuth2 credential that Lucid has for the 3rd party this extension works with */
    userCredential, 
    /** The data connector name from manifest.json that triggered this action */
    dataConnectorName, 
    /** The installation id of the extension/user that triggered this action */
    installationId, 
    /** Set of items this document is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */
    documentCollections, 
    /** Update filter type for this document */
    updateFilterType) {
        this.packageId = packageId;
        this.packageVersion = packageVersion;
        this.userCredential = userCredential;
        this.dataConnectorName = dataConnectorName;
        this.installationId = installationId;
        this.documentCollections = documentCollections;
        this.updateFilterType = updateFilterType;
    }
}
exports.DataConnectorActionContext = DataConnectorActionContext;
/** Base class for actions to be performed by data connectors */
class DataConnectorAction {
    constructor(name, context) {
        this.name = name;
        this.context = context;
    }
}
exports.DataConnectorAction = DataConnectorAction;
/**
 * A generic "asynchronous" action to be performed by the data connector. This is an action that reports back to Lucid
 * by calling back in the DataSourceClient rather than returning a meaningful value.
 **/
class DataConnectorAsynchronousAction extends DataConnectorAction {
    constructor(name, context, client, data) {
        super(name, context);
        this.client = client;
        this.data = data;
    }
}
exports.DataConnectorAsynchronousAction = DataConnectorAsynchronousAction;
/**
 * A generic "synchronous" action to be performed by the data connector.
 **/
class DataConnectorSynchronousAction extends DataConnectorAction {
    constructor(name, context, data) {
        super(name, context);
        this.data = data;
    }
}
exports.DataConnectorSynchronousAction = DataConnectorSynchronousAction;
/** A patch to be applied against the 3rd party datasource with changes coming from Lucid */
class Patch {
    constructor(
    /** The id of the patch */
    id, 
    /** Mapping of item primary keys to new items introduced by Lucid */
    itemsAdded, 
    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */
    itemsChanged, 
    /** List of item primary keys deleted by Lucid */
    itemsDeleted, 
    /** */
    itemOrderChanged, 
    /** The syncSourceId of the changed data source */
    syncSourceId, 
    /** The syncCollectionId of the changed collection */
    syncCollectionId) {
        this.id = id;
        this.itemsAdded = itemsAdded;
        this.itemsChanged = itemsChanged;
        this.itemsDeleted = itemsDeleted;
        this.itemOrderChanged = itemOrderChanged;
        this.syncSourceId = syncSourceId;
        this.syncCollectionId = syncCollectionId;
    }
    getChange(collections = []) {
        return new patchresponsebody_1.PatchChange(this.id, this.syncSourceId, collections);
    }
}
exports.Patch = Patch;
/**
 * A patch action is a kind of synchronous style action. It occurs when data is changed in the Lucid editor. All the
 * changes are collected in the patches field.
 **/
class DataConnectorPatchAction extends DataConnectorAction {
    constructor(context, 
    /** changes applied by Lucid */ patches, client, name = dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {
        super(name, context);
        this.patches = patches;
        this.client = client;
    }
}
exports.DataConnectorPatchAction = DataConnectorPatchAction;
/**
 * A description of an existing webhook that Lucid is keeping track of.
 **/
class Webhook {
    constructor(
    /** Set of items this webhook is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */
    documentCollections, 
    /** Arbitrary extra data to allow the data connector to better identitify the webhook. */
    webhookData) {
        this.documentCollections = documentCollections;
        this.webhookData = webhookData;
    }
}
exports.Webhook = Webhook;
/**
 * A "synchronous" style action indicating that Lucid would like to setup a webhook in the third party.
 */
class DataConnectorManageWebhookAction extends DataConnectorAction {
    constructor(context, 
    /**
     * Token to be added to the newly created webhook so that when it fires it will have permissions to make changes
     * to Lucid documents.
     */
    webhookToken, 
    /**
     * A list of existing webhooks so you can be more granular about what you track. You may also find it useful to
     * delete some of the existing webhooks. The response back to Lucid should include all existing webhooks (newly
     * created or any of these that were not deleted).
     **/
    webhooks) {
        super(dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook, context);
        this.webhookToken = webhookToken;
        this.webhooks = webhooks;
    }
}
exports.DataConnectorManageWebhookAction = DataConnectorManageWebhookAction;
