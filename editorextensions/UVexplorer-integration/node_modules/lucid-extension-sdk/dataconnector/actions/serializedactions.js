"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeActions = exports.actionsHeaderValidator = void 0;
const checks_1 = require("../../core/checks");
const validators_1 = require("../../core/validators/validators");
const dataupdatefiltertype_1 = require("../../data/dataupdatefiltertype");
const action_1 = require("./action");
const dataconnectoractionkeys_1 = require("./dataconnectoractionkeys");
exports.actionsHeaderValidator = (0, validators_1.objectValidator)({
    'x-lucid-rsa-nonce': checks_1.isString,
    'x-lucid-signature': checks_1.isString,
});
const serializedActionsBaseValidator = (0, validators_1.objectValidator)({
    action: (0, validators_1.objectValidator)({ name: checks_1.isString, data: checks_1.isUnknown }),
    packageId: checks_1.isString,
    packageVersion: (0, validators_1.nullableOption)(checks_1.isString),
    dataConnectorName: checks_1.isString,
    installationId: (0, validators_1.nullableOption)(checks_1.isString),
    userCredential: (0, validators_1.nullableOption)(checks_1.isString),
    documentUpdateToken: (0, validators_1.nullableOption)(checks_1.isString),
    documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
    updateFilterType: (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),
});
const serializedPatchDataValidator = (0, validators_1.objectValidator)({
    packageVersion: checks_1.isString,
    patches: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        patch: (0, validators_1.objectValidator)({
            itemsAdded: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),
            itemsChanged: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),
            itemsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),
            itemOrderChanged: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),
            syncSourceId: checks_1.isString,
            syncCollectionId: checks_1.isString,
            adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),
            syncSchema: checks_1.isUnknown,
        }),
        id: checks_1.isString,
    })),
    userCredential: checks_1.isString,
    documentUpdateToken: checks_1.isString,
});
const parseSerializedPatches = (patches) => {
    return patches.map((patch) => {
        var _a;
        const p = patch['patch'];
        return new action_1.Patch(patch['id'], p['itemsAdded'], p['itemsChanged'], p['itemsDeleted'], (_a = p['itemOrderChanged']) !== null && _a !== void 0 ? _a : undefined, p['syncSourceId'], p['syncCollectionId']);
    });
};
const serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({
    webhooks: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({
        documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),
        webhookData: (0, validators_1.option)(checks_1.isUnknown),
    })),
    webhookToken: checks_1.isString,
});
/** Function to convert the lucid action wire format into a clean list of actions */
function deserializeActions(client, actions) {
    if (!serializedActionsBaseValidator(actions)) {
        return;
    }
    const name = actions['action']['name'];
    const data = actions['action']['data'];
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {
        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {
            console.log(`Failing validation step`);
            return;
        }
        return data.map((item) => {
            const context = new action_1.DataConnectorActionContext(actions['packageId'], item['packageVersion'], item['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
            const patches = parseSerializedPatches(item['patches']);
            return new action_1.DataConnectorPatchAction(context, patches, client.getDataSourceClient(item['documentUpdateToken']));
        });
    }
    if (!actions['packageVersion'] || !actions['userCredential']) {
        return;
    }
    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {
        if (!serializedPatchDataValidator(data)) {
            return;
        }
        const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
        return [
            new action_1.DataConnectorPatchAction(context, parseSerializedPatches(data['patches']), client.getDataSourceClient(data['documentUpdateToken']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),
        ];
    }
    const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);
    if (name == 'ManageWebhook') {
        if (!serializedManageWebhookDataValidator(data)) {
            return;
        }
        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));
        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];
    }
    if (actions['documentUpdateToken']) {
        return [
            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(actions['documentUpdateToken']), data),
        ];
    }
    return [new action_1.DataConnectorSynchronousAction(name, context, data)];
}
exports.deserializeActions = deserializeActions;
