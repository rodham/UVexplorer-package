import { SerializedFieldTypeDefinition } from './core/data/fieldtypedefinition/fieldtypedefinition';
import { SerializedReferenceKeyType } from './core/data/referencekeys/serializedreferencekey';
import { SerializedFieldType } from './core/data/serializedfield/serializedfields';
import { JsonObject, JsonSerializable } from './core/jsonserializable';
import { LucidProduct } from './core/lucidproduct';
import { LinearOffsetType } from './core/offsettype';
import { SerializedDataError } from './core/serializeddataerror';
import { ShapeDataInheritance } from './core/shapedatainheritance';
import { DocumentAccessPermission } from './document/documentaccesspermission';
import { DocumentElementType } from './document/documentelement/documentelementtype';
import { SerializedLineTextAreaPositioning } from './document/linetextareapositioning';
import { TextStyle } from './document/text/textstyle';
import { Box, Point } from './math';
import { MenuLocation, MenuType } from './ui/menu';
import { PanelLocation } from './ui/panel';
/**
 * The lucid-extension-sdk library interacts with core Lucid products through this set of possible commands.
 * Typically, an extension author will not need to access any of these commands directly, as they are all
 * exposed through appropriate classes and methods elsewhere in this SDK.
 *
 * To use these directly, use [EditorClient.sendCommand](#classes_editorclient-EditorClient_sendcommand).
 *
 * FOR DEVELOPERS AT LUCID:
 * Follow this guide to add new commands: https://lucidatlassian.atlassian.net/wiki/x/3AA3Xww
 * Before you add a new command bring it up in #api-committee to get feedback.
 */
export declare const enum CommandName {
    AddCardIntegration = "aci",
    AddLineTextArea = "alta",
    AddMenuItem = "ami",
    AddShapeData = "asd",
    AddSpreadsheetIntegration = "asi",
    AddTableColumn = "atc",
    AddTableRow = "atr",
    Alert = "a",
    AnimateViewport = "av",
    AwaitDataSourceImport = "adi",
    AwaitImport = "ai",
    Bootstrap = "b",
    CalculateHash = "hsh",
    CancelDragBlockToCanvas = "cdc",
    CanEditPackageSettings = "ceps",
    Confirm = "c",
    CreateBlock = "cb",
    CreateCollection = "cc",
    CreateDataSource = "cds",
    CreateDocumentElement = "cde",
    CreateGroup = "cg",
    CreateLine = "cl",
    CreatePage = "cp",
    CreateUserImage = "cui",
    DataAction = "da",
    DataItemExists = "die",
    DeleteDocumentElement = "dde",
    DeleteItem = "di",
    DeletePage = "dp",
    DeleteShapeData = "dsd",
    DeleteTableColumn = "dtc",
    DeleteTableRow = "dtr",
    Download = "d",
    DragPointerMove = "dpm",
    DragPointerUp = "dpu",
    ElementExists = "ee",
    ExecuteFormula = "ef",
    FindAvailableSpace = "fas",
    FireBeaconEvent = "fbe",
    GetOAuthClientId = "goci",
    GetConnectedLines = "gcl",
    GetCurrentPage = "gcp",
    GetCustomShape = "gcs",
    GetDataItemField = "gdif",
    GetDocumentAccessPermission = "gdap",
    GetDocumentChunks = "gdc",
    GetDocumentId = "gdid",
    GetElementType = "get",
    GetEnvironmentConfig = "gec",
    GetItemPageId = "gip",
    GetItemsAt = "gia",
    GetLLMContextFromItems = "llm",
    GetOAuthToken = "got",
    GetPackageSettings = "gps",
    GetProduct = "gpr",
    GetProperty = "gp",
    GetReferenceKey = "grk",
    GetRelativeLinePosition = "grlp",
    GetSelection = "gs",
    GetShapeData = "gsd",
    GetSvg = "gsvg",
    GetTextStyle = "gts",
    GetUserId = "guid",
    GetVisibleRect = "gvr",
    HideModal = "hm",
    HidePanel = "hp",
    HookAllChanges = "hac",
    HookCreateItems = "hci",
    HookDeleteItems = "hdi",
    HookSelection = "hs",
    HookTextEdit = "hte",
    ImportCards = "ic",
    ImportLinks = "il",
    ImportPage = "imp",
    KillExtension = "k",
    ListBlocks = "lb",
    ListCollectionFields = "lcf",
    ListCollections = "lc",
    ListDataItems = "ldi",
    ListDataSources = "lds",
    ListDocumentElements = "lde",
    ListGroups = "lg",
    ListLines = "ll",
    ListPages = "lp",
    ListProperties = "lpr",
    ListReferenceKeys = "lrk",
    ListShapeData = "lsd",
    ListTextAreas = "lta",
    LoadBlockClasses = "lbc",
    LogForTestCase = "log",
    MeasureText = "mt",
    AddDiagramFromMermaid = "adfm",
    OffsetItems = "oi",
    PatchDataItems = "pdi",
    Prompt = "p",
    RegisterPanel = "rp",
    RegisterUnfurl = "ru",
    ReloadExtension = "r",
    SendOAuthRequest = "oauth",
    SendAsyncOAuthRequest = "aoauth",
    SendPermanentTokenRequest = "perm",
    SendUIMessage = "suim",
    SendXHR = "xhr",
    SetCurrentPage = "scp",
    SetPackageSettings = "sps",
    SetProperty = "sp",
    SetReferenceKey = "srk",
    SetSelection = "ss",
    SetShapeData = "ssd",
    SetText = "st",
    SetTextStyle = "sts",
    ShowModal = "sm",
    ShowPanel = "spn",
    ShowPackageSettingsModal = "spsm",
    SleepForTestCase = "sleep",
    StartDragBlockToCanvas = "sdc",
    StartPDFUploadRequest = "pdf",
    ThrowForTestCase = "throw",
    TriggerAuthFlow = "tauth",
    UnhookAllChanges = "uac",
    UnhookCreateItems = "uci",
    UnhookDeleteItems = "udi",
    UnhookSelection = "us",
    UnhookTextEdit = "ute",
    WithMutex = "wm",
    WithSilentActions = "wsa",
    ZOrder = "z"
}
/** @ignore */
export declare const commandTitles: Map<CommandName, string>;
/**
 * This is a type declaration whose purpose is to allow TypeScript to enforce the correct parameter and
 * return types from [EditorClient.sendCommand](#classes_editorclient-EditorClient_sendcommand) based on
 * which command name you pass in as the first parameter.
 *
 * IMPORTANT - Before you add a new command bring it up in #api-committee to get feedback
 */
export type CommandArgs = {
    [CommandName.AddCardIntegration]: {
        query: AddCardIntegrationQuery;
        result: AddCardIntegrationResult;
    };
    [CommandName.AddLineTextArea]: {
        query: AddLineTextAreaQuery;
        result: AddLineTextAreaResult;
    };
    [CommandName.AddMenuItem]: {
        query: AddMenuItemQuery;
        result: AddMenuItemResult;
    };
    [CommandName.AddShapeData]: {
        query: AddShapeDataQuery;
        result: AddShapeDataResult;
    };
    [CommandName.AddSpreadsheetIntegration]: {
        query: AddSpreadsheetIntegrationQuery;
        result: AddSpreadsheetIntegrationResult;
    };
    [CommandName.AddTableColumn]: {
        query: AddTableColumnQuery;
        result: AddTableColumnResult;
    };
    [CommandName.AddTableRow]: {
        query: AddTableRowQuery;
        result: AddTableRowResult;
    };
    [CommandName.Alert]: {
        query: AlertQuery;
        result: AlertResult;
    };
    [CommandName.AnimateViewport]: {
        query: AnimateViewportQuery;
        result: AnimateViewportResult;
    };
    [CommandName.AwaitDataSourceImport]: {
        query: AwaitDataSourceImportQuery;
        result: AwaitDataSourceImportResult;
    };
    [CommandName.AwaitImport]: {
        query: AwaitImportQuery;
        result: AwaitImportResult;
    };
    [CommandName.Bootstrap]: {
        query: BootstrapQuery;
        result: BootstrapResult;
    };
    [CommandName.CalculateHash]: {
        query: CalculateHashQuery;
        result: CalculateHashResult;
    };
    [CommandName.CanEditPackageSettings]: {
        query: CanEditPackageSettingsQuery;
        result: CanEditPackageSettingsResult;
    };
    [CommandName.CancelDragBlockToCanvas]: {
        query: CancelDragBlockToCanvasQuery;
        result: CancelDragBlockToCanvasResult;
    };
    [CommandName.Confirm]: {
        query: ConfirmQuery;
        result: ConfirmResult;
    };
    [CommandName.CreateBlock]: {
        query: CreateBlockQuery;
        result: CreateBlockResult;
    };
    [CommandName.CreateCollection]: {
        query: CreateCollectionQuery;
        result: CreateCollectionResult;
    };
    [CommandName.CreateDataSource]: {
        query: CreateDataSourceQuery;
        result: CreateDataSourceResult;
    };
    [CommandName.CreateDocumentElement]: {
        query: CreateDocumentElementQuery;
        result: CreateDocumentElementResult;
    };
    [CommandName.CreateGroup]: {
        query: CreateGroupQuery;
        result: CreateGroupResult;
    };
    [CommandName.CreateLine]: {
        query: CreateLineQuery;
        result: CreateLineResult;
    };
    [CommandName.CreatePage]: {
        query: CreatePageQuery;
        result: CreatePageResult;
    };
    [CommandName.CreateUserImage]: {
        query: CreateUserImageQuery;
        result: CreateUserImageResult;
    };
    [CommandName.DataAction]: {
        query: DataActionQuery;
        result: DataActionResult;
    };
    [CommandName.DataItemExists]: {
        query: DataItemExistsQuery;
        result: DataItemExistsResult;
    };
    [CommandName.DeleteDocumentElement]: {
        query: DeleteDocumentElementQuery;
        result: DeleteDocumentElementResult;
    };
    [CommandName.DeleteItem]: {
        query: DeleteItemQuery;
        result: DeleteItemResult;
    };
    [CommandName.DeletePage]: {
        query: DeletePageQuery;
        result: DeletePageResult;
    };
    [CommandName.DeleteShapeData]: {
        query: DeleteShapeDataQuery;
        result: DeleteShapeDataResult;
    };
    [CommandName.DeleteTableColumn]: {
        query: DeleteTableColumnQuery;
        result: DeleteTableColumnResult;
    };
    [CommandName.DeleteTableRow]: {
        query: DeleteTableRowQuery;
        result: DeleteTableRowResult;
    };
    [CommandName.Download]: {
        query: DownloadQuery;
        result: DownloadResult;
    };
    [CommandName.DragPointerMove]: {
        query: DragPointerMoveQuery;
        result: DragPointerMoveResult;
    };
    [CommandName.DragPointerUp]: {
        query: DragPointerUpQuery;
        result: DragPointerUpResult;
    };
    [CommandName.ElementExists]: {
        query: ElementExistsQuery;
        result: ElementExistsResult;
    };
    [CommandName.ExecuteFormula]: {
        query: ExecuteFormulaQuery;
        result: ExecuteFormulaResult;
    };
    [CommandName.FindAvailableSpace]: {
        query: FindAvailableSpaceQuery;
        result: FindAvailableSpaceResult;
    };
    [CommandName.FireBeaconEvent]: {
        query: FireBeaconEventQuery;
        result: FireBeaconEventResult;
    };
    [CommandName.GetOAuthClientId]: {
        query: GetOAuthClientIdQuery;
        result: GetOAuthClientIdResult;
    };
    [CommandName.GetConnectedLines]: {
        query: GetConnectedLinesQuery;
        result: GetConnectedLinesResult;
    };
    [CommandName.GetCurrentPage]: {
        query: GetCurrentPageQuery;
        result: GetCurrentPageResult;
    };
    [CommandName.GetCustomShape]: {
        query: GetCustomShapeQuery;
        result: GetCustomShapeResult;
    };
    [CommandName.GetDataItemField]: {
        query: GetDataItemFieldQuery;
        result: GetDataItemFieldResult;
    };
    [CommandName.GetDocumentAccessPermission]: {
        query: GetDocumentAccessPermissionQuery;
        result: GetDocumentAccessPermissionResult;
    };
    [CommandName.GetDocumentChunks]: {
        query: GetDocumentChunksQuery;
        result: GetDocumentChunksResult;
    };
    [CommandName.GetDocumentId]: {
        query: GetDocumentIdQuery;
        result: GetDocumentIdResult;
    };
    [CommandName.GetElementType]: {
        query: GetElementTypeQuery;
        result: GetElementTypeResult;
    };
    [CommandName.GetEnvironmentConfig]: {
        query: GetEnvironmentConfigQuery;
        result: GetEnvironmentConfigResult;
    };
    [CommandName.GetItemPageId]: {
        query: GetItemPageIdQuery;
        result: GetItemPageIdResult;
    };
    [CommandName.GetItemsAt]: {
        query: GetItemsAtQuery;
        result: GetItemsAtResult;
    };
    [CommandName.GetLLMContextFromItems]: {
        query: GetLLMContextFromItemsQuery;
        result: GetLLMContextFromItemsResult;
    };
    [CommandName.GetOAuthToken]: {
        query: GetOAuthTokenQuery;
        result: GetOAuthTokenResult;
    };
    [CommandName.GetPackageSettings]: {
        query: GetPackageSettingsQuery;
        result: GetPackageSettingsResult;
    };
    [CommandName.GetProduct]: {
        query: GetProductQuery;
        result: GetProductResult;
    };
    [CommandName.GetProperty]: {
        query: GetPropertyQuery;
        result: GetPropertyResult;
    };
    [CommandName.GetReferenceKey]: {
        query: GetReferenceKeyQuery;
        result: GetReferenceKeyResult;
    };
    [CommandName.GetRelativeLinePosition]: {
        query: GetRelativeLinePositionQuery;
        result: GetRelativeLinePositionResult;
    };
    [CommandName.GetSelection]: {
        query: GetSelectionQuery;
        result: GetSelectionResult;
    };
    [CommandName.GetShapeData]: {
        query: GetShapeDataQuery;
        result: GetShapeDataResult;
    };
    [CommandName.GetSvg]: {
        query: GetSvgQuery;
        result: GetSvgResult;
    };
    [CommandName.GetTextStyle]: {
        query: GetTextStyleQuery;
        result: GetTextStyleResult;
    };
    [CommandName.GetUserId]: {
        query: GetUserIdQuery;
        result: GetUserIdResult;
    };
    [CommandName.GetVisibleRect]: {
        query: GetVisibleRectQuery;
        result: GetVisibleRectResult;
    };
    [CommandName.HideModal]: {
        query: HideModalQuery;
        result: HideModalResult;
    };
    [CommandName.HidePanel]: {
        query: HidePanelQuery;
        result: HidePanelResult;
    };
    [CommandName.HookAllChanges]: {
        query: HookAllChangesQuery;
        result: HookAllChangesResult;
    };
    [CommandName.HookCreateItems]: {
        query: HookCreateItemsQuery;
        result: HookCreateItemsResult;
    };
    [CommandName.HookDeleteItems]: {
        query: HookDeleteItemsQuery;
        result: HookDeleteItemsResult;
    };
    [CommandName.HookSelection]: {
        query: HookSelectionQuery;
        result: HookSelectionResult;
    };
    [CommandName.HookTextEdit]: {
        query: HookTextEditQuery;
        result: HookTextEditResult;
    };
    [CommandName.KillExtension]: {
        query: KillExtensionQuery;
        result: KillExtensionResult;
    };
    [CommandName.ImportCards]: {
        query: ImportCardsQuery;
        result: ImportCardsResult;
    };
    [CommandName.ImportLinks]: {
        query: ImportLinksQuery;
        result: ImportLinksResult;
    };
    [CommandName.ImportPage]: {
        query: ImportPageQuery;
        result: ImportPageResult;
    };
    [CommandName.ListBlocks]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListCollectionFields]: {
        query: ListCollectionFieldsQuery;
        result: ListCollectionFieldsResult;
    };
    [CommandName.ListCollections]: {
        query: ListCollectionsQuery;
        result: ListCollectionsResult;
    };
    [CommandName.ListDataItems]: {
        query: ListDataItemsQuery;
        result: ListDataItemsResult;
    };
    [CommandName.ListDataSources]: {
        query: ListDataSourcesQuery;
        result: ListDataSourcesResult;
    };
    [CommandName.ListDocumentElements]: {
        query: ListDocumentElementsQuery;
        result: ListDocumentElementsResult;
    };
    [CommandName.ListGroups]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListLines]: {
        query: ListChildrenQuery;
        result: ListChildrenResult;
    };
    [CommandName.ListPages]: {
        query: ListPagesQuery;
        result: ListPagesResult;
    };
    [CommandName.ListProperties]: {
        query: ListPropertiesQuery;
        result: ListPropertiesResult;
    };
    [CommandName.ListReferenceKeys]: {
        query: ListReferenceKeysQuery;
        result: ListReferenceKeysResult;
    };
    [CommandName.ListShapeData]: {
        query: ListShapeDataQuery;
        result: ListShapeDataResult;
    };
    [CommandName.ListTextAreas]: {
        query: ListTextAreasQuery;
        result: ListTextAreasResult;
    };
    [CommandName.LoadBlockClasses]: {
        query: LoadBlockClassesQuery;
        result: LoadBlockClassesResult;
    };
    [CommandName.LogForTestCase]: {
        query: JsonSerializable;
        result: JsonSerializable;
    };
    [CommandName.MeasureText]: {
        query: MeasureTextQuery;
        result: MeasureTextResult;
    };
    [CommandName.AddDiagramFromMermaid]: {
        query: AddDiagramFromMermaidQuery;
        result: AddDiagramFromMermaidResult;
    };
    [CommandName.OffsetItems]: {
        query: OffsetItemsQuery;
        result: OffsetItemsResult;
    };
    [CommandName.PatchDataItems]: {
        query: PatchDataItemsQuery;
        result: PatchDataItemsResult;
    };
    [CommandName.Prompt]: {
        query: PromptQuery;
        result: PromptResult;
    };
    [CommandName.RegisterPanel]: {
        query: RegisterPanelQuery;
        result: RegisterPanelResult;
    };
    [CommandName.RegisterUnfurl]: {
        query: RegisterUnfurlQuery;
        result: RegisterUnfurlResult;
    };
    [CommandName.ReloadExtension]: {
        query: ReloadExtensionQuery;
        result: ReloadExtensionResult;
    };
    [CommandName.SendOAuthRequest]: {
        query: SendOAuthRequestQuery;
        result: SendOAuthRequestResponse;
    };
    [CommandName.SendAsyncOAuthRequest]: {
        query: SendAsyncOAuthRequestQuery;
        result: SendOAuthRequestResponse;
    };
    [CommandName.SendPermanentTokenRequest]: {
        query: SendPermanentTokenRequestQuery;
        result: SendOAuthRequestResponse;
    };
    [CommandName.SendUIMessage]: {
        query: SendUIMessageQuery;
        result: SendUIMessageResult;
    };
    [CommandName.SendXHR]: {
        query: SendXHRQuery;
        result: SendXHRResponse;
    };
    [CommandName.SetCurrentPage]: {
        query: SetCurrentPageQuery;
        result: SetCurrentPageResult;
    };
    [CommandName.SetPackageSettings]: {
        query: SetPackageSettingsQuery;
        result: SetPackageSettingsResult;
    };
    [CommandName.SetProperty]: {
        query: SetPropertyQuery;
        result: SetPropertyResult;
    };
    [CommandName.SetReferenceKey]: {
        query: SetReferenceKeyQuery;
        result: SetReferenceKeyResult;
    };
    [CommandName.SetSelection]: {
        query: SetSelectionQuery;
        result: SetSelectionResult;
    };
    [CommandName.SetShapeData]: {
        query: SetShapeDataQuery;
        result: SetShapeDataResult;
    };
    [CommandName.SetText]: {
        query: SetTextQuery;
        result: SetTextResult;
    };
    [CommandName.SetTextStyle]: {
        query: SetTextStyleQuery;
        result: SetTextStyleResult;
    };
    [CommandName.ShowModal]: {
        query: ShowModalQuery;
        result: ShowModalResult;
    };
    [CommandName.ShowPackageSettingsModal]: {
        query: ShowPackageSettingsModalQuery;
        result: ShowPackageSettingsModalResult;
    };
    [CommandName.ShowPanel]: {
        query: ShowPanelQuery;
        result: ShowPanelResult;
    };
    [CommandName.SleepForTestCase]: {
        query: SleepForTestCaseQuery;
        result: SleepForTestCaseResult;
    };
    [CommandName.StartDragBlockToCanvas]: {
        query: StartDragBlockToCanvasQuery;
        result: StartDragBlockToCanvasResult;
    };
    [CommandName.StartPDFUploadRequest]: {
        query: StartPDFUploadRequestQuery;
        result: StartPDFUploadRequestResponse;
    };
    [CommandName.ThrowForTestCase]: {
        query: ThrowForTestCaseQuery;
        result: ThrowForTestCaseResult;
    };
    [CommandName.TriggerAuthFlow]: {
        query: TriggerAuthFlowQuery;
        result: TriggerAuthFlowResult;
    };
    [CommandName.UnhookAllChanges]: {
        query: UnhookAllChangesQuery;
        result: UnhookAllChangesResult;
    };
    [CommandName.UnhookCreateItems]: {
        query: UnhookCreateItemsQuery;
        result: UnhookCreateItemsResult;
    };
    [CommandName.UnhookDeleteItems]: {
        query: UnhookDeleteItemsQuery;
        result: UnhookDeleteItemsResult;
    };
    [CommandName.UnhookSelection]: {
        query: UnhookSelectionQuery;
        result: UnhookSelectionResult;
    };
    [CommandName.UnhookTextEdit]: {
        query: UnhookTextEditQuery;
        result: UnhookTextEditResult;
    };
    [CommandName.WithMutex]: {
        query: WithMutexQuery;
        result: WithMutexResult;
    };
    [CommandName.WithSilentActions]: {
        query: WithSilentActionsQuery;
        result: WithSilentActionsResult;
    };
    [CommandName.ZOrder]: {
        query: ZOrderQuery;
        result: ZOrderResult;
    };
};
export type AddCardIntegrationQuery = {
    /** Title/name */
    'n': string;
    /** Data connector name */
    'dcn': string;
    /** Item label */
    'il': string;
    /** Items label */
    'isl': string;
    /** Icon url */
    'u': string;
    /** Text style */
    'ts'?: Partial<TextStyle> | undefined;
    /** Field configuration */
    'fc': {
        /** Callback to get field definitions for all fields supported by the card integration */
        'gf': string;
        /** Callback to handle a change in the fields the user want to be displayed */
        'osfc'?: string | undefined;
        /** Field name -> callback name tuples for searching for legal field values in an enum */
        'fvsc'?: [string, string][] | undefined;
    };
    /** Show intro if user has not yet authorized this integration */
    'i'?: string | undefined;
    /** Get default config action */
    'gdc': string;
    /** If specified, import modal settings */
    'im'?: {
        /** Get search fields action */
        'gsf': string;
        /** Search action */
        's': string;
        /** Import action */
        'i': string;
        /** OnSetup action */
        'os'?: string | undefined;
    } | undefined;
    /** If specified, custom import modal via iframe url */
    'cim'?: {
        'su': string;
        'w': number;
        'h': number;
        'i': string;
    };
    /** If specified, add-card settings */
    'ac'?: {
        /** Get input fields action */
        'gif': string;
        /** Create card action */
        'cc': string;
    } | undefined;
};
export type AddCardIntegrationResult = undefined;
export type AddLineTextAreaQuery = {
    /** Which line */
    'id': string;
    /** Where to place the text along the line */
    'p': SerializedLineTextAreaPositioning;
    /** Plain text to put at this location (will be styled with document theme) */
    't': string;
};
/** The name of the created text area */
export type AddLineTextAreaResult = string;
/** @ignore */
export type UnionToIntersection<T> = (T extends any ? (x: T) => unknown : never) extends (x: infer R) => unknown ? R : never;
export type AddMenuItemQuery = {
    /** Label to display on the menu item */
    'l': string;
    /** Url of the Icon to display on the menu item */
    'i'?: string | undefined;
    /** Named action to run when the menu item is clicked */
    'a'?: string | undefined;
    /** Named action that returns whether the menu item should be visible */
    'v'?: string | undefined;
    /** Named action that returns whether the menu item should be disabled */
    'd'?: string | undefined;
    /** Which menu to put the item in */
    't': MenuType;
    /** If specified, where to place the menu item; defaults to MenuLocation.Extension */
    'loc'?: MenuLocation | undefined;
    /** If specified, this menu item should launch a file picker */
    'f'?: {
        /** Action to call when files are selected */
        'a': string;
        /** File types to accept */
        'ac': string;
        /** Single file only */
        's'?: boolean | undefined;
        /** Return content in a binary ArrayBuffer instead of as text */
        'b'?: boolean | undefined;
    } | undefined;
};
export type AddMenuItemResult = undefined;
export type AddShapeDataQuery = {
    /** ID of the element to add this shape data to */
    'id'?: string | undefined;
    /** Name for this shape data */
    'n': string;
    /** Inheritance setting for the new shape data */
    'i': ShapeDataInheritance;
    /** Initial value of this shape data; use a string beginning with '=' for a formula */
    'v'?: SerializedFieldType;
};
export type AddShapeDataResult = undefined;
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export type AddSpreadsheetIntegrationQuery = {
    /** labelDescription */
    'ld': string;
    /** labelIconUrl */
    'li': string;
    /** dataConnectorName */
    'dc': string;
    /** getSpreadsheetDetailsToImport */
    'gs': string;
    /** getMultipleSheetsForSpreadsheetDetails */
    'gm': string;
};
/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */
export type AddSpreadsheetIntegrationResult = undefined;
export type AddTableColumnQuery = {
    /** ID of the table to add this column to */
    'id': string;
    /** Row of the reference cell that the column should be added next to */
    'r': number;
    /** Column of the reference cell that the column should be added next to */
    'c': number;
    /** True if the column should be added before the reference cell */
    'b': boolean;
};
/** The index of the newly created column */
export type AddTableColumnResult = number;
export type AddTableRowQuery = {
    /** ID of the table to add this row to */
    'id': string;
    /** Row of the reference cell that the row should be added next to */
    'r': number;
    /** Column of the reference cell that the row should be added next to */
    'c': number;
    /** True if the row should be added before the reference cell */
    'b': boolean;
};
/** The index of the newly created row */
export type AddTableRowResult = number;
export type AlertQuery = {
    /** Title; defaults to extension title */
    't'?: string | undefined;
    /** Body text */
    'b': string;
    /** Button text; defaults to i18n'ed "OK" */
    'bt'?: string | undefined;
};
/** True if they click OK, false otherwise */
export type AlertResult = Promise<boolean>;
export type AwaitDataSourceImportQuery = {
    /** Data Connector Name */
    'n': string;
    /** Sync data source ID Nonce */
    's': string;
};
/** Promise resolving to the data source ID where the data arrived */
export type AwaitDataSourceImportResult = Promise<string>;
export type AwaitImportQuery = {
    /** Data Connector Name */
    'n': string;
    /** Sync data source ID Nonce */
    's'?: string | undefined;
    /** Sync collection ID */
    'c': string;
    /** Keys to await */
    'pk': string[];
    /** Timeout in milliseconds; reject returned promise if no data appears in time */
    't': number;
};
/** Promise resolving to the collection ID where the data arrived */
export type AwaitImportResult = Promise<string>;
export type BootstrapQuery = {
    /**
     * Named action that accepts the bootstrap data, and which may return a Promise or void. After awaiting\
     * the result of the callback, the bootstrap data is cleared.
     */
    'c': string;
    /**
     * Marks a document as requiring the editor extension.
     */
    'm'?: boolean | undefined;
};
export type BootstrapResult = Promise<void>;
export declare enum HashAlgorithmEnum {
    /** Use the SHA 256 hashing algorithm */
    sha256 = "SHA256"
}
export type CalculateHashQuery = {
    'a': HashAlgorithmEnum;
    's': string;
};
export type CalculateHashResult = string;
export type CanEditPackageSettingsQuery = undefined;
export type CanEditPackageSettingsResult = Promise<boolean>;
export type CancelDragBlockToCanvasQuery = void;
export type CancelDragBlockToCanvasResult = undefined;
export type ConfirmQuery = {
    /** Title; defaults to extension title */
    't'?: string | undefined;
    /** Body text */
    'b': string;
    /** OK button text; defaults to i18n'ed "OK" */
    'o'?: string | undefined;
    /** Cancel button text; defaults to i18n'ed "Cancel" */
    'c'?: string | undefined;
};
/** True if they click OK, false otherwise */
export type ConfirmResult = Promise<boolean>;
export type CreateBlockQuery = {
    /**
     * By default, we add the block to the current page & currently active group. If specified, the
     * block will instead be created as a direct child of the given page.
     */
    'p'?: string | undefined;
    /** Class name of the block to create */
    'c': string;
    /** If specified, the stencil for a custom shape. Only valid if the class name is 'CustomBlock' */
    's'?: JsonSerializable | undefined;
};
export type CreateBlockResult = string;
export type CreateGroupQuery = {
    /**
     * By default, we add the group to the current page & currently active group. If specified, the
     * group will instead be created as a direct child of the given page.
     */
    'p'?: string | undefined;
    /** List of item IDs to group */
    'i': string[];
};
export type CreateGroupResult = string;
export type CreateCollectionFieldDefinition = {
    /** Name of the field */
    'n': string;
    /** Type of the values in this field */
    't': SerializedFieldTypeDefinition;
};
export type CreateCollectionQuery = {
    /** ID of the data source to add this collection to */
    's': string;
    /** Name of the collection */
    'n': string;
    /** Fields that can be set on data items in this collection */
    'f': CreateCollectionFieldDefinition[];
    /** Field(s) to use as the primary key of this collection */
    'p': string[];
    'fl'?: Record<string, string> | undefined;
};
export type CreateCollectionResult = string;
export type CreateDataSourceQuery = {
    /** Name of the data source */
    'n': string;
    /** Source configuration for this data source--information about where it came from, or any metadata that might be useful */
    's': {
        [key: string]: JsonSerializable;
    };
};
export type CreateDataSourceResult = string;
export type CreateDocumentElementQuery = {
    /** Type of element to create */
    't': DocumentElementType;
    /** Properties to set on that element */
    'p': Record<string, any>;
};
export type CreateDocumentElementResult = string | undefined;
export type CreateLineQuery = {
    /**
     * By default, we add the line to the current page & currently active group. If specified, the
     * line will instead be created as a direct child of the given page.
     */
    'p'?: string | undefined;
};
export type CreateLineResult = string;
export type CreatePageQuery = void;
export type CreatePageResult = string;
export type CreateUserImageQuery = {
    /** media type */
    't': string;
    /** base64-encoded image data */
    'd': string;
};
export type RawCreateUserImageResult = {
    /** The resulting image URL */
    'u': string;
};
export type CreateUserImageResult = Promise<RawCreateUserImageResult>;
export type DataActionQuery = {
    /** Flow Name */
    'fn': string;
    /** Is Async */
    'a': boolean;
    /** Flow Data */
    'fd'?: unknown;
    /** Sync data source ID Nonce */
    's'?: string | undefined;
    /** Data Connector Name */
    'n': string;
};
export type RawDataActionResult = {
    /** The external service responded with this code */
    'c': number;
} & ({
    /** And this text */
    't': string;
} | {
    /** Or this JSON */
    'j': unknown;
});
export type DataActionResult = Promise<RawDataActionResult>;
export type DataItemExistsQuery = {
    /** Collection ID to check */
    'c': string;
    /** Primary key to check */
    'pk': string;
};
export type DataItemExistsResult = boolean;
export type DeleteDocumentElementQuery = string;
export type DeleteDocumentElementResult = boolean;
export type DeleteItemQuery = string;
export type DeleteItemResult = boolean;
export type DeletePageQuery = string;
export type DeletePageResult = boolean;
export type DeleteShapeDataQuery = {
    /** ID of the element to delete this shape data from */
    'id'?: string | undefined;
    /** Name for this shape data */
    'n': string;
};
export type DeleteShapeDataResult = undefined;
export type DeleteTableColumnQuery = {
    /** ID of the table to delete this column from */
    'id': string;
    /** Index of the column to delete */
    'i': number;
};
export type DeleteTableColumnResult = void;
export type DeleteTableRowQuery = {
    /** ID of the table to delete this row from */
    'id': string;
    /** Index of the row to delete */
    'i': number;
};
export type DeleteTableRowResult = void;
export type DownloadQuery = {
    /** Filename of the download */
    'f': string;
    /** Data to put in the file */
    'd': string;
    /** MIME type for the download */
    'm': string;
    /** If true, data is base64-encoded and should be converted to binary for download */
    'b64': boolean;
};
export type DownloadResult = undefined;
export type DragPointerMoveQuery = {
    'x': number;
    'y': number;
};
export type DragPointerMoveResult = undefined;
export type DragPointerUpQuery = {
    'x': number;
    'y': number;
};
export type DragPointerUpResult = undefined;
export type ElementExistsQuery = {
    'id'?: string | undefined;
};
export type ElementExistsResult = boolean;
export type ExecuteFormulaQuery = {
    /** ID of the element to execute a formula on */
    'id': string;
    /** Formula to execute, e.g. '@a + @b' or 'CONTAINEDBY' */
    'f': string;
};
export type ExecuteFormulaResult = SerializedFieldType | SerializedDataError;
export type FindAvailableSpaceQuery = {
    /** If specified, the page to find space on. Otherwise use the visible page. */
    'p'?: string | undefined;
    /** If specified, the location to search near. Otherwise use the viewport. */
    'x'?: number | undefined;
    /** If specified, the location to search near. Otherwise use the viewport. */
    'y'?: number | undefined;
    /** Width */
    'w': number;
    /** Height */
    'h': number;
};
export type FindAvailableSpaceResult = {
    /** ID of the page you should add content to */
    'p': string;
    /** Origin of the rectangle of empty space */
    'x': number;
    /** Origin of the rectangle of empty space */
    'y': number;
};
export type FireBeaconEventQuery = {
    /** the beacon event to be sent */
    'e': string;
};
export type FireBeaconEventResult = void;
export type AnimateViewportQuery = {
    /** ID of the page to view */
    'p': string;
    /** Bounding box on that page that will fill as much of the viewport as possible */
    'bb': Box;
};
export type AnimateViewportResult = Promise<void>;
export type GetElementTypeQuery = {
    'id'?: string | undefined;
};
export type GetElementTypeResult = 'block' | 'line' | 'group' | 'visual-activity' | 'page' | 'document' | 'generator' | 'panel';
export type GetEnvironmentConfigQuery = string;
export type GetEnvironmentConfigResult = JsonSerializable;
export type GetConnectedLinesQuery = string;
export type GetConnectedLinesResult = string[];
export type GetCurrentPageQuery = void;
export type GetCurrentPageResult = string | undefined;
export type GetCustomShapeQuery = {
    /** Name of the custom shape library in this same extension package */
    'l': string;
    /** Name of the shape in that library to find */
    's': string;
};
export type GetCustomShapeResult = Promise<{
    /** Value which can be used as the Stencil property on a dynamic shape */
    's': JsonSerializable;
    /** Default size (x:0, y:0) of this custom shape */
    'bb': Box;
    /** Other default property values */
    'p': JsonObject;
} | undefined>;
export type GetDataItemFieldQuery = {
    /** Collection ID to query */
    'c': string;
    /** Primary key of the data item to read */
    'pk': string;
    /** Name of field to read */
    'f': string;
};
export type GetDataItemFieldResult = SerializedFieldType;
export type GetDocumentAccessPermissionQuery = void;
export type GetDocumentAccessPermissionResult = DocumentAccessPermission;
export declare enum GetDocumentChunksType {
    /**
     * Breaks up a document into chunks geographically
     */
    Geographic = 0,
    /**
     * Breaks up a document into chunks by finding containing blocks
     */
    Container = 1
}
export type GetDocumentChunksQuery = {
    't': GetDocumentChunksType[];
};
export type GetDocumentChunksResult = SerializedDocumentChunk[];
type SerializedDocumentChunk = {
    /** Bounding box of all items combined */
    'bb': Box;
    /** Ids of the items included in the chunk */
    'i': string[];
    't': string;
    /** Very brief description that helps describe the chunk */
    'd': string;
};
export type GetDocumentIdQuery = void;
export type GetDocumentIdResult = string;
export type GetItemPageIdQuery = string;
export type GetItemPageIdResult = string;
export declare enum GetItemsAtSearchType {
    PossiblyOverlapping = 0,
    Overlapping = 1,
    Contained = 2
}
export type GetItemsAtQuery = {
    /** Page ID to search */
    'p': string;
    /** Bounding box to search */
    'bb': Box;
    /** Search type */
    's': GetItemsAtSearchType;
};
/** IDs of the items found */
export type GetItemsAtResult = string[];
export declare enum GetLLMContextType {
    /** Get context in a format for LLMs where relationships among connected and
     * contained items are preserved. Expand the scope of the selection to
     * include blocks contained by the selection as well as lines connecting
     * items in the selection. */
    Relational = 1,
    /** Get context containing only plain text displayed on the given items, more suitable for embeddings */
    PlainText = 2,
    /** Get context in a format for LLMs where relationships among connected and
     * contained items are preserved. Do not expand the scope of the selection,
     * other than to ensure relationships are represented. Text on selected
     * items will be included, but text on automatically added items will not.
     * */
    RelationalWithoutExpansion = 3
}
export type GetLLMContextFromItemsQuery = {
    /** Page ID to find closely-related items */
    'p': string;
    /** List of item IDs to return LLM-readable context for */
    'i': string[];
    /** Type of context to get */
    't'?: GetLLMContextType | undefined;
};
export type GetLLMContextFromItemsResult = {
    /**
     * A string in a format that LLMs like ChatGPT can easily understand, representing the content
     * of the items specified as well as their immediate context if necessary
     */
    'p': string;
    /**
     * A map from IDs specified in the prompt string to actual Lucid item IDs
     */
    'id': Record<string, string>;
};
export type GetReferenceKeyQuery = {
    /** ID of the LucidElement to read a reference key from, or undefined to read from the LucidDocument */
    'id'?: string | undefined;
    /** Reference key to get */
    'k': number | string;
};
export type GetReferenceKeyResult = SerializedReferenceKeyType;
export type GetOAuthTokenQuery = {
    /** OAuth provider name as specified in the package manifest */
    'p': string;
};
export type GetOAuthTokenResult = Promise<string | undefined>;
export type GetProductQuery = undefined;
export type GetProductResult = LucidProduct;
export type GetOAuthClientIdQuery = {
    /** OAuth provider name as specified in the package manifest */
    'p': string;
};
export type GetOAuthClientIdResult = Promise<string | undefined>;
export type GetPropertyQuery = {
    /** ID of the LucidElement to read a property from, or undefined to read from the LucidDocument */
    'id'?: string | undefined;
    /** Name of the property to read */
    'p': string;
};
export type GetPropertyResult = JsonSerializable;
export type GetPackageSettingsQuery = undefined;
export type GetPackageSettingsResult = Promise<Record<string, JsonSerializable>>;
export type GetRelativeLinePositionQuery = {
    /** Block or line ID to check the connections on */
    'id': string;
    /** Relative position in range of [0,1] along the line */
    'p': number;
};
export type GetRelativeLinePositionResult = Point;
export type GetSelectionQuery = {
    /** If set, additionally return all items inside selected groups */
    'd'?: boolean | undefined;
};
export type GetSelectionResult = string[];
export type GetShapeDataQuery = {
    /** ID of the element to query shape data from */
    'id'?: string | undefined;
    /** Name of the shape data to read */
    'n': string;
};
export type GetShapeDataResult = SerializedFieldType | SerializedDataError;
export type GetSvgQuery = {
    /** Page ID to get an image of */
    'p': string;
    /** True to include the background of the page */
    'bg': boolean;
    /** If specified, the bounding box specifying what portion of the page to show */
    'bb'?: Box | undefined;
    /** If specified, only include these item IDs */
    'i'?: string[] | undefined;
};
export type GetSvgResult = Promise<string>;
export type GetTextStyleQuery = {
    /** ID of the element to get text style from */
    'id': string;
    /** Name of the text area to get text style from */
    'n': string;
};
export type GetTextStyleResult = TextStyle;
export type GetUserIdQuery = void;
export type GetUserIdResult = string;
export type GetVisibleRectQuery = void;
export type GetVisibleRectResult = Box;
export type HideModalQuery = {
    /** Name of the modal's action for receiving events, i.e. ShowModalQuery['n'] */
    'n': string;
};
export type HideModalResult = undefined;
export type HidePanelQuery = {
    /** Name of the panel's action for receiving events, i.e. RegisterPanelQuery['n'] */
    'n': string;
};
export type HidePanelResult = undefined;
export type HookAllChangesQuery = {
    /** Name of the action for receiving events. Will be called with no parameters periodically as changes are made to the document */
    'n': string;
};
export type HookAllChangesResult = undefined;
export type HookCreateItemsQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all recently created item IDs. */
    'n': string;
};
export type HookCreateItemsResult = undefined;
export type HookDeleteItemsQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all recently deleted item IDs. */
    'n': string;
};
export type HookDeleteItemsResult = undefined;
export type HookSelectionQuery = {
    /** Name of the action for receiving events. Will be called with an array of strings of all selected item IDs. */
    'n': string;
};
export type HookSelectionResult = undefined;
export type HookTextEditQuery = {
    /** Name of the action for receiving these events */
    'n': string;
    /** Whether to trigger the text hook callback eagerly during text edit */
    'e'?: boolean | undefined;
};
export type HookTextEditResult = undefined;
/** Name of the card integration registered by this extension to show the import dialog for */
export type ImportCardsQuery = string;
/** Resolves when the import dialog is closed */
export type ImportCardsResult = Promise<void>;
export type ImportLinksQuery = {
    /**
     * By default, we import the links onto the current page. If specified, the links will instead be imported onto the given page.
     */
    'p'?: string | undefined;
    /** Links to be imported onto the canvas as link unfurl blocks*/
    'l': string[];
};
export type ImportLinksResult = void;
export type ImportPageQuery = {
    /** The ID of the document or template to import */
    'id': string;
    /** Page numbers of specified document or template to import (zero-indexed) */
    'n': number[];
};
/** Resolves when the import succeeds or fails */
export type ImportPageResult = Promise<void>;
export type KillExtensionQuery = void;
export type KillExtensionResult = undefined;
export type ListChildrenQuery = {
    /** Parent ID to search inside */
    'id': string;
    /** "deep" - If true, get all children at any level of group nesting; otherwise only immediate children */
    'd'?: boolean;
};
export type ListChildrenResult = string[];
export type ListCollectionsQuery = {
    /** ID of the data source to list collections for */
    'id': string;
};
export type ListCollectionsResult = string[];
export type ListDataItemsQuery = {
    /** Collection ID to list items from */
    'id': string;
};
export type ListDataItemsResult = string[];
export type ListCollectionFieldsQuery = {
    /** Collection ID to query */
    'id': string;
};
export type ListCollectionFieldsResult = string[];
export type ListDataSourcesQuery = undefined;
export type ListDataSourcesResult = string[];
export type ListDocumentElementsQuery = {
    't': DocumentElementType;
};
export type ListDocumentElementsResult = string[];
export type ListPagesQuery = void;
export type ListPagesResult = string[];
export type ListReferenceKeysQuery = {
    /** ID of the element to list reference keys for, or undefined for the document */
    'id'?: string | undefined;
};
/** Reference key IDs */
export type ListReferenceKeysResult = (string | number)[];
export type ListPropertiesQuery = {
    'id'?: string | undefined;
};
export type ListPropertiesResult = string[];
export type ListShapeDataQuery = {
    'id'?: string | undefined;
    /** True to include inherited shape data from containing groups and/or page */
    'i'?: boolean | undefined;
};
export type ListShapeDataResult = string[];
export type ListTextAreasQuery = string;
export type ListTextAreasResult = string[];
export type LoadBlockClassesQuery = string[];
export type LoadBlockClassesResult = Promise<undefined>;
export type MeasureTextQuery = {
    /** ID of the element to measure text area */
    'id': string;
    /** Name of the text area to measure */
    'n': string;
    /** Max width for giving text area*/
    'w': number;
};
export type MeasureTextResult = {
    /** Text area width */
    'w': number;
    /** Text area height */
    'h': number;
};
export declare enum MermaidDiagramType {
    FLOWCHART = "flowchart"
}
export type AddDiagramFromMermaidQuery = {
    /** Type of diagram as an enum, e.g., flowchart. */
    't': MermaidDiagramType;
    /** A mermaid diagram syntax string, e.g., flowchart TD\nA --> B */
    'm': string;
    /** The point on the canvas for placing the diagram */
    'o'?: Point | undefined;
    /** If true, place the diagram exactly at the point. Otherwise, place it in open space near the point. */
    'e'?: boolean | undefined;
};
/** A list of shape ids that represent the mermaid diagram. Empty if the rendering fails. */
export type AddDiagramFromMermaidResult = Promise<string[]>;
export type OffsetItemsQuery = {
    /** IDs of the items (blocks, lines, groups) to move */
    'ids': string[];
    /** What kind of offset to perform */
    't': LinearOffsetType;
    /** How far to offset */
    'o': Point;
};
export type OffsetItemsResult = undefined;
export type PatchDataItemsQuery = {
    /** ID of the data collection to patch */
    'id': string;
    /** Data items to add to the collection */
    'a': Record<string, SerializedFieldType>[];
    /** Data items to change field values on, keyed by primary key */
    'c': Record<string, Record<string, SerializedFieldType>>;
    /** Primary keys of items to delete */
    'd': string[];
};
/** Primary keys inserted, if any */
export type PatchDataItemsResult = string[];
export type PromptQuery = {
    /** Title; defaults to extension title */
    't'?: string | undefined;
    /** Body text */
    'b': string;
};
export type PromptResult = Promise<string | undefined>;
export type RegisterPanelQuery = {
    /** Name of the panel's action for receiving events; generated automatically by Panel base class */
    'n': string;
    /** Title to show on the panel */
    't': string;
    /** Where to display the panel */
    'l': PanelLocation;
    /** Named action that returns whether the button to open the panel should be visible */
    'v'?: string | undefined;
    /** Content to display in the panel; full HTML page preferred */
    'c'?: string | undefined;
    /** URL to display in the panel (this or c is required). Can be relative to /public directory in the package */
    'u'?: string | undefined;
    /** Icon URL, preferably a base64-encoded URL */
    'i': string;
    /** tooltip */
    'to'?: string;
    /** If true, we will persist the panel's iframe */
    'p'?: boolean;
    /** Desired panel width */
    'w'?: number | undefined;
    /** Desired panel height */
    'h'?: number | undefined;
};
export type RegisterPanelResult = undefined;
export type RegisterUnfurlQuery = {
    /** Domain to unfurl, e.g. www.google.com */
    'd': string;
    /** For backwards compatility */
    'a'?: string | undefined;
    /** Unfurl Action name for the unfurl handler */
    'ua'?: string | undefined;
    /** After Unfurl Action name for the unfurl handler */
    'aua'?: string | undefined;
    /** Expand Callback Action name for the unfurl handler */
    'e'?: string | undefined;
};
export type RegisterUnfurlResult = boolean;
export type ReloadExtensionQuery = void;
export type ReloadExtensionResult = undefined;
export type SendOAuthRequestQuery = SendXHRQuery & {
    /** OAuth provider name as specified in the package manifest */
    'p': string;
    /** Post Result To */
    'prt'?: string | undefined;
};
export type SendAsyncOAuthRequestQuery = SendXHRQuery & {
    /** OAuth provider name as specified in the package manifest */
    'p': string;
};
export type SendPermanentTokenRequestQuery = SendXHRQuery & {
    /** Permanent token provider name as specified in the package manifest */
    'p': string;
};
export type SendOAuthRequestResponse = SendXHRResponse;
export type SendPermanentTokenRequestResponse = SendXHRResponse;
export type SendUIMessageQuery = {
    /** Name of the UI component's action for receiving events, e.g. ShowModalQuery['n'] */
    'n': string;
    /** Content of the message to send to the custom UI component */
    'd'?: JsonSerializable;
};
export type SendUIMessageResult = undefined;
export type SendXHRResponseFormat = 'utf8' | 'binary';
export type SendXHRQuery = {
    'url': string;
    /** HTTP method, e.g. 'GET', 'FETCH', etc. Defaults to GET */
    'm'?: string | undefined;
    /**
     * The data to send with the request.
     *
     * For GET requests, this specifies the query string.
     *
     * For non-GET requests, this is sent as the body of the request. If this is specified, and
     *   no 'Content-Type' header is specified, a 'text/plain; charset=utf-8' content type is sent.
     */
    'd'?: string | undefined;
    /** Headers to send with the request */
    'h'?: {
        [key: string]: string | string[];
    } | undefined;
    /** Timeout in milliseconds, if specified */
    'ms'?: number | undefined;
    /**
     * The desired format for the returned response body. Defaults to 'utf8'.
     *
     * - If 'utf8', the response body will be returned as a string.
     * - If 'binary', the response body will be returned as a Uint8Array.
     */
    'f'?: SendXHRResponseFormat | undefined;
    /**
     * If set, a callback to call with chunks of the response as they arrive.
     * Only valid for utf8 (text) requests, and only called on successful responses.
     * The full final response will still be returned as normal.
     */
    's'?: string | undefined;
};
export type RawSendXHRResponse = {
    /** URL of the response after any redirects */
    'url': string;
    /** Plain-text or base64-encoded response body */
    't': string;
    /** Status code of the response */
    's': number;
    /** Headers sent with the response */
    'h': {
        [key: string]: string;
    };
    /** true if the request timed out */
    'to'?: boolean;
};
export type SendXHRResponse = Promise<RawSendXHRResponse>;
export declare function isRawSendXHRResponse(val: any): val is RawSendXHRResponse;
export type SetCurrentPageQuery = string;
export type SetCurrentPageResult = Promise<void>;
export type SetPackageSettingsQuery = Record<string, string>;
export type SetPackageSettingsResult = Promise<undefined>;
export type SetPropertyQuery = {
    /** ID of the element to change */
    'id'?: string | undefined;
    /** Name of the property to change */
    'p': string;
    /** New value of the property */
    'v'?: JsonSerializable;
};
export type SetPropertyResult = undefined;
export type SetReferenceKeyQuery = {
    /** ID of the element to set the reference key on */
    'id'?: string | undefined;
    /** ID of the reference key to set */
    'k': string | number;
    /** New reference key settings, or undefined to remove the reference key */
    'v'?: SerializedReferenceKeyType | undefined;
};
export type SetReferenceKeyResult = undefined;
export type SetSelectionQuery = {
    /** IDs of the elements to select */
    'i': string[];
};
export type SetSelectionResult = undefined;
export type SetShapeDataQuery = {
    /** ID of the element to set this shape data on */
    'id'?: string | undefined;
    /** Name for the already-existing shape data to update */
    'n': string;
    /** Value to set; use a string beginning with '=' for a formula */
    'v'?: SerializedFieldType;
};
export type SetShapeDataResult = undefined;
export type SetTextQuery = {
    /** ID of the element to change text on */
    'id': string;
    /** Name of the text area to update */
    'n': string;
    /** Plain text to put in the text area*/
    't': string;
    /** Optional force boolean for extension to update uneditable items*/
    'f'?: boolean | undefined;
};
export type SetTextResult = undefined;
export type SetTextStyleQuery = {
    /** ID of the element to set text style on */
    'id': string;
    /** Name of the text area to set text style on */
    'n': string;
    /** Text styles to set */
    's': Partial<TextStyle>;
};
export type SetTextStyleResult = Promise<undefined>;
export type ShowModalQuery = {
    /** Name of the modal's action for receiving events; generated automatically by Modal base class */
    'n': string;
    /** Title to show on the modal */
    't'?: string | undefined;
    /** Desired modal width */
    'w'?: number | undefined;
    /** Desired modal height */
    'h'?: number | undefined;
    /** Chromeless (without a header and borders) or not */
    'cl'?: boolean | undefined;
    /** FullScreen or not */
    'fs'?: boolean | undefined;
    /** TransparentBackground or not */
    'tb'?: boolean | undefined;
    /** Content to display in the modal; full HTML page preferred */
    'c'?: string | undefined;
    /** URL to display in the modal (this or c is required). Can be relative to /public directory in the package */
    'u'?: string | undefined;
};
export type ShowModalResult = Promise<undefined>;
export type ShowPackageSettingsModalQuery = undefined;
export type ShowPackageSettingsModalResult = Promise<void>;
export type ShowPanelQuery = {
    /** Name of the panel's action for receiving events, i.e. RegisterPanelQuery['n'] */
    'n': string;
};
export type ShowPanelResult = undefined;
export type SleepForTestCaseQuery = number;
export type SleepForTestCaseResult = Promise<void>;
export type StartDragBlockToCanvasQuery = {
    /** Class name of the block to create */
    'c': string;
    /** Size of the block to create */
    'sz': {
        'w': number;
        'h': number;
    };
    /** Additional properties to set on the block being dragged */
    'p': {
        [key: string]: JsonSerializable;
    };
    /** If specified, the stencil for a custom shape. Only valid if the class name is 'CustomBlock' */
    's'?: JsonSerializable | undefined;
};
export type StartDragBlockToCanvasResult = Promise<string | undefined>;
export type StartPDFUploadRequestQuery = string;
/**
 * @ignore
 * A signed URL you can upload the pdf to. You can do this manually (via the client, your own service) or via the
 * oauth proxy.
 */
export type StartPDFUploadRequestResponse = Promise<string>;
export type ThrowForTestCaseQuery = number;
export type ThrowForTestCaseResult = undefined | Promise<void>;
export type TriggerAuthFlowQuery = {
    /** OAuth or merge provider name as specified in the package manifest */
    'p': string;
};
export type TriggerAuthFlowResult = Promise<RawTriggerAuthFlowResult>;
export type RawTriggerAuthFlowResult = {
    's': boolean;
};
export type UnhookAllChangesQuery = {
    /** Name of the action passed to HookAllChanges */
    'n': string;
};
export type UnhookAllChangesResult = undefined;
export type UnhookCreateItemsQuery = {
    /** Name of the action passed to HookCreateItems */
    'n': string;
};
export type UnhookCreateItemsResult = undefined;
export type UnhookDeleteItemsQuery = {
    /** Name of the action passed to HookDeleteItems */
    'n': string;
};
export type UnhookDeleteItemsResult = undefined;
export type UnhookSelectionQuery = {
    /** Name of the action for receiving these events */
    'n': string;
};
export type UnhookSelectionResult = undefined;
export type UnhookTextEditQuery = {
    /** Name of the action for receiving these events */
    'n': string;
};
export type UnhookTextEditResult = undefined;
export type WithMutexQuery = {
    /** Name of the intra-document mutex to hold for the duration of this action */
    'n': string;
    /** Name of the action to run within the given mutex */
    'a': string;
};
/** Resolves true if operation succeeded, or false if the mutex was held by someone else */
export type WithMutexResult = Promise<boolean>;
export type WithSilentActionsQuery = {
    /** Name of the synchronous action to run with undo/redo history suppressed */
    'a': string;
};
export type WithSilentActionsResult = void;
export declare enum ZOrderOperation {
    UP = 1,
    TOP = 2,
    DOWN = 3,
    BOTTOM = 4
}
export type ZOrderQuery = {
    /** IDs of the items to adjust Z order */
    'i': string[];
    /** Operation to perform on these items */
    'o': ZOrderOperation;
};
export type ZOrderResult = undefined;
export {};
