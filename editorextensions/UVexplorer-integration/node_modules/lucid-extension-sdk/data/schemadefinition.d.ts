import { isNumber, isUndefined } from '../core/checks';
import { FieldTypeDefinition } from '../core/data/fieldtypedefinition/fieldtypedefinition';
import { SemanticFields } from '../core/data/fieldtypedefinition/semanticfields';
import { SemanticKind } from '../core/data/fieldtypedefinition/semantickind';
import { FieldConstraintType, SerializedFieldConstraint, SerializedFieldDefinition } from '../core/data/serializedfield/serializedfielddefinition';
import { SerializedSchema } from '../core/data/serializedfield/serializedschema';
export interface RequiredFieldConstraintDefinition {
    type: FieldConstraintType.REQUIRED;
    value?: undefined;
}
export interface LockedFieldConstraintDefinition {
    type: FieldConstraintType.LOCKED;
    value?: undefined;
}
export interface MinValueFieldConstraintDefinition {
    type: FieldConstraintType.MIN_VALUE;
    value: number;
}
export interface MaxValueFieldConstraintDefinition {
    type: FieldConstraintType.MAX_VALUE;
    value: number;
}
export interface SingleLineFieldConstraintDefinition {
    type: FieldConstraintType.SINGLE_LINE_ONLY;
    value?: undefined;
}
export interface NoWhitespaceFieldConstraintDefinition {
    type: FieldConstraintType.NO_WHITESPACE;
    value?: undefined;
}
export interface UniqueEditFieldConstraintDefinition {
    type: FieldConstraintType.UNIQUE_EDIT;
    value?: undefined;
}
export type FieldConstraintDefinition = RequiredFieldConstraintDefinition | LockedFieldConstraintDefinition | MinValueFieldConstraintDefinition | MaxValueFieldConstraintDefinition | SingleLineFieldConstraintDefinition | NoWhitespaceFieldConstraintDefinition | UniqueEditFieldConstraintDefinition;
export declare function minMaxFieldConstraintValidator(val: unknown): val is FieldConstraintType.MIN_VALUE | FieldConstraintType.MAX_VALUE;
export declare const isFieldConstraintDefinition: (x: unknown) => x is {
    type?: FieldConstraintType | undefined;
} & {
    type: FieldConstraintType;
} & (import("..").DestructureGuardedTypeObj<{
    type: typeof minMaxFieldConstraintValidator;
    value: typeof isNumber;
}> | import("..").DestructureGuardedTypeObj<{
    type: (x: unknown) => x is FieldConstraintType.REQUIRED | FieldConstraintType.LOCKED | FieldConstraintType.SINGLE_LINE_ONLY | FieldConstraintType.NO_WHITESPACE | FieldConstraintType.UNIQUE_EDIT;
    value: typeof isUndefined;
}>);
/**
 * The definition for a field to be included in a [SchemaDefinition](#interfaces_data_schemadefinition-SchemaDefinition)
 */
export interface FieldDefinition {
    name: string;
    type: FieldTypeDefinition;
    constraints?: FieldConstraintDefinition[] | undefined;
    mapping?: readonly SemanticFields[] | readonly SemanticKind[] | undefined;
}
/**
 * Definition of a schema for creating a [Collection](#classes_data_collectionproxy-CollectionProxy)
 */
export interface SchemaDefinition {
    fields: FieldDefinition[];
    /**
     * Field names that are used to construct primary keys for new data items.
     * Typically this contains only one field name, and that field is usually unique.
     */
    primaryKey: string[];
    /**
     * Maps field names to labels to display in the UI when necessary. If any field name
     * is not present as a key in this label map, the field name itself will be the label.
     */
    fieldLabels?: Record<string, string>;
}
/** @ignore */
export declare function serializeFieldConstraintDefinition(constraint: FieldConstraintDefinition): SerializedFieldConstraint;
/** @ignore */
export declare function serializeFieldDefinition(field: FieldDefinition): SerializedFieldDefinition;
/** @ignore */
export declare function serializeSchemaDefinition(def: SchemaDefinition): SerializedSchema;
/** @ignore */
export declare function parseFieldDefinition(field: SerializedFieldDefinition): FieldDefinition;
/** @ignore */
export declare function parseSchemaDefinition(def: SerializedSchema): SchemaDefinition;
