"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionProxy = void 0;
const checks_1 = require("../core/checks");
const mapproxy_1 = require("../document/mapproxy");
const propertystoreproxy_1 = require("../document/propertystoreproxy");
const branchedcollectionid_1 = require("./branchedcollectionid");
const dataitemproxy_1 = require("./dataitemproxy");
const patchcollectionproxy_1 = require("./patchcollectionproxy");
const schemadefinition_1 = require("./schemadefinition");
/**
 * A collection is a set of data items, each with the same set of fields (though some data items may not have all
 * fields defined).
 */
class CollectionProxy extends propertystoreproxy_1.PropertyStoreProxy {
    /**
     *
     * @param id ID of this collection on the current document
     * @param client
     */
    constructor(id, client) {
        super(id, client);
        this.id = id;
        /**
         * The data items in this collection, organized by their primary key. The primary key is usually calculated
         * from the content of the data item, but may differ from the expected value in some circumstances, e.g. if
         * there are two data items that would have the same primary key.
         */
        this.items = new mapproxy_1.MapProxy(() => this.client.sendCommand("ldi" /* CommandName.ListDataItems */, { 'id': this.id }), (primaryKey) => new dataitemproxy_1.DataItemProxy(primaryKey, this, this.client));
    }
    /**
     * @returns a human-readable name for this collection
     */
    getName() {
        return this.properties.get('Name');
    }
    getSyncCollectionId() {
        const upstreamConfig = this.properties.get('UpstreamConfig');
        if ((0, checks_1.isObjectUnsafe)(upstreamConfig) && (0, checks_1.isString)(upstreamConfig['SyncId'])) {
            return upstreamConfig['SyncId'];
        }
        return undefined;
    }
    /**
     * Some data collections may have local branches on the document, to store the set of changes that have been
     * made by the user since the time the data was last refreshed from its source. For those collections, you
     * can use this method to get the original data collection as it was last imported or refreshed.
     *
     * @returns the original collection from which this collection was branched, or undefined if this collection
     * is not a branch
     */
    getBranchedFrom() {
        const id = this.properties.get('BranchedFrom');
        return id ? new CollectionProxy(id, this.client) : undefined;
    }
    /**
     * @returns information about any changes made locally to the collection that have not been synchronized
     * with the external data source.
     */
    getLocalChanges() {
        const patchCollectionId = (0, branchedcollectionid_1.patchCollectionIdFromPossibleBranchedCollectionId)(this.id);
        const original = this.getBranchedFrom();
        if (!patchCollectionId || !original) {
            return undefined;
        }
        return new patchcollectionproxy_1.PatchCollectionProxy(this.client, this, new CollectionProxy(patchCollectionId, this.client), original);
    }
    patchItems(patch) {
        var _a, _b;
        const changed = {};
        if (patch.changed) {
            for (const [primaryKey, record] of patch.changed) {
                changed[primaryKey] = record;
            }
        }
        return this.client.sendCommand("pdi" /* CommandName.PatchDataItems */, {
            'id': this.id,
            'a': (_a = patch.added) !== null && _a !== void 0 ? _a : [],
            'c': changed,
            'd': (_b = patch.deleted) !== null && _b !== void 0 ? _b : [],
        });
    }
    /**
     * @returns an array of field names that are accessible on the items in this collection
     */
    getFields() {
        return this.client.sendCommand("lcf" /* CommandName.ListCollectionFields */, { 'id': this.id });
    }
    getSchema() {
        // we wave to cast as unknown because of readonly being used in the type
        return (0, schemadefinition_1.parseSchemaDefinition)(this.properties.get('Schema'));
    }
}
exports.CollectionProxy = CollectionProxy;
