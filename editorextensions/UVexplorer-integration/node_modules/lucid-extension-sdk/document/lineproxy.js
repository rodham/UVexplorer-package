"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineProxy = exports.LineShape = void 0;
const checks_1 = require("../core/checks");
const blockproxy_1 = require("./blockproxy");
const itemproxy_1 = require("./itemproxy");
const linetextareapositioning_1 = require("./linetextareapositioning");
var LineShape;
(function (LineShape) {
    LineShape["Curve"] = "curve";
    LineShape["Elbow"] = "elbow";
    LineShape["Diagonal"] = "diagonal";
})(LineShape || (exports.LineShape = LineShape = {}));
/**
 * A line on the current Lucid document
 */
class LineProxy extends itemproxy_1.ItemProxy {
    getConnection(ep) {
        let proxy;
        if (ep['Block']) {
            proxy = this.client.getBlockProxy(ep['Block']);
        }
        if (ep['Line']) {
            proxy = this.client.getLineProxy(ep['Line']);
        }
        if (proxy && !proxy.exists()) {
            return undefined;
        }
        return proxy;
    }
    isBlockEndpointDefinition(ep) {
        return ep.connection instanceof blockproxy_1.BlockProxy;
    }
    isLineEndpointDefinition(ep) {
        return ep.connection instanceof LineProxy;
    }
    parseLineEndpointDefinition(raw) {
        const connection = this.getConnection(raw);
        if (connection instanceof LineProxy) {
            return {
                connection,
                style: raw['Style'],
                position: raw['Position'],
                x: raw['x'],
                y: raw['y'],
            };
        }
        else if (connection) {
            return {
                connection,
                style: raw['Style'],
                linkX: raw['LinkX'],
                linkY: raw['LinkY'],
                inside: raw['Inside'],
                autoLink: raw['AutoLink'],
                padding: raw['Padding'],
                x: raw['x'],
                y: raw['y'],
            };
        }
        else {
            return {
                style: raw['Style'],
                x: raw['x'],
                y: raw['y'],
            };
        }
    }
    serializeLineEndpointDefinition(ep) {
        if (this.isBlockEndpointDefinition(ep)) {
            const bb = ep.connection.getBoundingBox();
            return {
                'Style': ep.style,
                'x': bb.x + bb.w * ep.linkX,
                'y': bb.y + bb.h * ep.linkY,
                'Block': ep.connection.id,
                'LinkX': ep.linkX,
                'LinkY': ep.linkY,
                'Inside': ep.inside,
                'AutoLink': ep.autoLink,
                'Padding': ep.padding,
            };
        }
        else if (this.isLineEndpointDefinition(ep)) {
            return Object.assign({ 'Style': ep.style, 'Line': ep.connection.id, 'LineP': ep.position }, ep.connection.getRelativePosition(ep.position));
        }
        else {
            return {
                'Style': ep.style,
                'x': ep.x,
                'y': ep.y,
            };
        }
    }
    /**
     * @returns The definition of the first endpoint of this line
     */
    getEndpoint1() {
        return this.parseLineEndpointDefinition(this.properties.get('Endpoint1'));
    }
    /**
     * @returns The definition of the second endpoint of this line
     */
    getEndpoint2() {
        return this.parseLineEndpointDefinition(this.properties.get('Endpoint2'));
    }
    /**
     * Update the first endpoint of this line
     * @param endpoint Line endpoint definition
     */
    setEndpoint1(endpoint) {
        this.properties.set('Endpoint1', this.serializeLineEndpointDefinition(endpoint));
    }
    /**
     * Update the second endpoint of this line
     * @param endpoint Line endpoint definition
     */
    setEndpoint2(endpoint) {
        this.properties.set('Endpoint2', this.serializeLineEndpointDefinition(endpoint));
    }
    /**
     * @returns The block or line connected to the first endpoint of this line, or `undefined` if none
     */
    getUpstreamConnection() {
        return this.getEndpoint1().connection;
    }
    /**
     * @returns The block or line connected to the second endpoint of this line, or `undefined` if none
     */
    getDownstreamConnection() {
        return this.getEndpoint2().connection;
    }
    /**
     * @returns A list of lines whose endpoints are connected to this line
     */
    getConnectedLines() {
        const ids = this.client.sendCommand("gcl" /* CommandName.GetConnectedLines */, this.id);
        return ids.map((id) => this.client.getLineProxy(id));
    }
    /**
     * @param relative A distance, between 0 and 1, between the first and second endpoint of this line
     * @returns The coordinate of that relative position, relative to the containing page
     */
    getRelativePosition(relative) {
        return this.client.sendCommand("grlp" /* CommandName.GetRelativeLinePosition */, { 'id': this.id, 'p': relative });
    }
    /**
     *
     * @param name
     * @returns The position of the given text area on this line, if it exists, or undefined if it does not exist.
     */
    getTextAreaPosition(name) {
        const serializedTextAreas = this.properties.get('TextAreas');
        if ((0, checks_1.isObjectUnsafe)(serializedTextAreas)) {
            const rawEntry = serializedTextAreas[name];
            if ((0, linetextareapositioning_1.isSerializedLineTextAreaPositioning)(rawEntry)) {
                return (0, linetextareapositioning_1.deserializeLineTextAreaPositioning)(rawEntry);
            }
        }
        return undefined;
    }
    /**
     * Updates the position of the given text area, if it exists. If not, an error is thrown.
     * @param name
     * @param position
     */
    setTextAreaPosition(name, position) {
        this.properties.set('TextAreas', { [name]: (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position) });
    }
    /**
     * Adds a new text area to this line at the given location with the given initial plain text.
     * The text will be styled with the document theme, if any.
     * @param text
     * @param position
     * @returns The name of the text area added
     */
    addTextArea(text, position) {
        return this.client.sendCommand("alta" /* CommandName.AddLineTextArea */, {
            'id': this.id,
            'p': (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position),
            't': text,
        });
    }
    /**
     * Deletes the given text area from the line, if it exists.
     * @param name
     */
    deleteTextArea(name) {
        this.properties.set('TextAreas', { [name]: null });
    }
    getShape() {
        return this.properties.get('Shape');
    }
    setShape(shape) {
        this.properties.set('Shape', shape);
    }
}
exports.LineProxy = LineProxy;
